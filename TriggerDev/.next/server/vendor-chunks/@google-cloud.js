"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@google-cloud";
exports.ids = ["vendor-chunks/@google-cloud"];
exports.modules = {

/***/ "(rsc)/./node_modules/@google-cloud/precise-date/build/src/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@google-cloud/precise-date/build/src/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PreciseDate = void 0;\nconst FULL_ISO_REG = /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d{4,9}Z/;\nconst NO_BIG_INT = 'BigInt only available in Node >= v10.7. Consider using getFullTimeString instead.';\nvar Sign;\n(function (Sign) {\n    Sign[Sign[\"NEGATIVE\"] = -1] = \"NEGATIVE\";\n    Sign[Sign[\"POSITIVE\"] = 1] = \"POSITIVE\";\n    Sign[Sign[\"ZERO\"] = 0] = \"ZERO\";\n})(Sign || (Sign = {}));\n/**\n * The native Date object.\n * @external Date\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date}\n */\n/**\n * @typedef {array} DateTuple\n * @property {number} 0 Represents seconds of UTC time since Unix epoch\n *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n *     9999-12-31T23:59:59Z inclusive.\n * @property {number} 1 Non-negative fractions of a second at nanosecond\n *     resolution. Negative second values with fractions must still have\n *     non-negative nanos values that count forward in time. Must be from 0 to\n *     999,999,999 inclusive.\n */\n/**\n * @typedef {object} DateStruct\n * @property {number} seconds Represents seconds of UTC time since Unix epoch\n *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n *     9999-12-31T23:59:59Z inclusive.\n * @property {number} nanos Non-negative fractions of a second at nanosecond\n *     resolution. Negative second values with fractions must still have\n *     non-negative nanos values that count forward in time. Must be from 0 to\n *     999,999,999 inclusive.\n */\n/**\n * Date object with nanosecond precision. Supports all standard Date arguments\n * in addition to several custom types as noted below.\n *\n * @class\n * @extends external:Date\n *\n * @param {number|string|bigint|Date|DateTuple|DateStruct} [time] The time\n *     value.\n * @param {...number} [dateFields] Additional date fields (month, date, hours,\n *     minutes, seconds, milliseconds, microseconds, nanoseconds).\n *\n * @example <caption>With a RFC 3339 formatted string.</caption>\n * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n *\n * @example <caption>With a nanosecond timestamp string.</caption>\n * const date = new PreciseDate('1549622069481320032');\n *\n * @example <caption>With a BigInt (requires Node >= v10.7)</caption>\n * const date = new PreciseDate(1549622069481320032n);\n *\n * @example <caption>With a tuple containing seconds and nanoseconds.</caption>\n * const date = new PreciseDate([1549622069, 481320032]);\n *\n * @example <caption>With an object containing `seconds` and `nanos`</caption>\n * const date = new PreciseDate({seconds: 1549622069, nanos: 481320032});\n *\n * @example <caption>Specifiying date fields</caption>\n * const date = new PreciseDate(2018, 5, 14, 41, 11, 34, 123, 874, 321);\n */\nclass PreciseDate extends Date {\n    constructor(time) {\n        super();\n        this._micros = 0;\n        this._nanos = 0;\n        if (time && typeof time !== 'number' && !(time instanceof Date)) {\n            this.setFullTime(PreciseDate.parseFull(time));\n            return;\n        }\n        // eslint-disable-next-line prefer-rest-params\n        const args = Array.from(arguments);\n        const dateFields = args.slice(0, 7);\n        const date = new Date(...dateFields);\n        const nanos = args.length === 9 ? args.pop() : 0;\n        const micros = args.length === 8 ? args.pop() : 0;\n        this.setTime(date.getTime());\n        this.setMicroseconds(micros);\n        this.setNanoseconds(nanos);\n    }\n    /**\n     * Returns the specified date represented in nanoseconds according to\n     * universal time.\n     *\n     * **NOTE:** Because this method returns a `BigInt` it requires Node >= v10.7.\n     * Use {@link PreciseDate#getFullTimeString} to get the time as a string.\n     *\n     * @see {@link https://github.com/tc39/proposal-bigint|BigInt}\n     *\n     * @throws {error} If `BigInt` is unavailable.\n     * @returns {bigint}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.getFullTime());\n     * // expected output: 1549622069481145231n\n     */\n    getFullTime() {\n        if (typeof BigInt !== 'function') {\n            throw new Error(NO_BIG_INT);\n        }\n        return BigInt(this.getFullTimeString());\n    }\n    /**\n     * Returns a string of the specified date represented in nanoseconds according\n     * to universal time.\n     *\n     * @returns {string}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.getFullTimeString());\n     * // expected output: \"1549622069481145231\"\n     */\n    getFullTimeString() {\n        const seconds = this._getSeconds();\n        let nanos = this._getNanos();\n        if (nanos && Math.sign(seconds) === Sign.NEGATIVE) {\n            nanos = 1e9 - nanos;\n        }\n        return `${seconds}${padLeft(nanos, 9)}`;\n    }\n    /**\n     * Returns the microseconds in the specified date according to universal time.\n     *\n     * @returns {number}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145Z');\n     *\n     * console.log(date.getMicroseconds());\n     * // expected output: 145\n     */\n    getMicroseconds() {\n        return this._micros;\n    }\n    /**\n     * Returns the nanoseconds in the specified date according to universal time.\n     *\n     * @returns {number}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.getNanoseconds());\n     * // expected output: 231\n     */\n    getNanoseconds() {\n        return this._nanos;\n    }\n    /**\n     * Sets the microseconds for a specified date according to universal time.\n     *\n     * @param {number} microseconds A number representing the microseconds.\n     * @returns {string} Returns a string representing the nanoseconds in the\n     *     specified date according to universal time.\n     *\n     * @example\n     * const date = new PreciseDate();\n     *\n     * date.setMicroseconds(149);\n     *\n     * console.log(date.getMicroseconds());\n     * // expected output: 149\n     */\n    setMicroseconds(micros) {\n        const abs = Math.abs(micros);\n        let millis = this.getUTCMilliseconds();\n        if (abs >= 1000) {\n            millis += Math.floor(abs / 1000) * Math.sign(micros);\n            micros %= 1000;\n        }\n        if (Math.sign(micros) === Sign.NEGATIVE) {\n            millis -= 1;\n            micros += 1000;\n        }\n        this._micros = micros;\n        this.setUTCMilliseconds(millis);\n        return this.getFullTimeString();\n    }\n    /**\n     * Sets the nanoseconds for a specified date according to universal time.\n     *\n     * @param {number} nanoseconds A number representing the nanoseconds.\n     * @returns {string} Returns a string representing the nanoseconds in the\n     *     specified date according to universal time.\n     *\n     * @example\n     * const date = new PreciseDate();\n     *\n     * date.setNanoseconds(231);\n     *\n     * console.log(date.getNanoseconds());\n     * // expected output: 231\n     */\n    setNanoseconds(nanos) {\n        const abs = Math.abs(nanos);\n        let micros = this._micros;\n        if (abs >= 1000) {\n            micros += Math.floor(abs / 1000) * Math.sign(nanos);\n            nanos %= 1000;\n        }\n        if (Math.sign(nanos) === Sign.NEGATIVE) {\n            micros -= 1;\n            nanos += 1000;\n        }\n        this._nanos = nanos;\n        return this.setMicroseconds(micros);\n    }\n    /**\n     * Sets the PreciseDate object to the time represented by a number of\n     * nanoseconds since January 1, 1970, 00:00:00 UTC.\n     *\n     * @param {bigint|number|string} time Value representing the number of\n     *     nanoseconds since January 1, 1970, 00:00:00 UTC.\n     * @returns {string} Returns a string representing the nanoseconds in the\n     *     specified date according to universal time (effectively, the value of\n     *     the argument).\n     *\n     * @see {@link https://github.com/tc39/proposal-bigint|BigInt}\n     *\n     * @example <caption>With a nanosecond string.</caption>\n     * const date = new PreciseDate();\n     * date.setFullTime('1549622069481145231');\n     *\n     * @example <caption>With a BigInt</caption>\n     * date.setFullTime(1549622069481145231n);\n     */\n    setFullTime(time) {\n        if (typeof time !== 'string') {\n            time = time.toString();\n        }\n        const sign = Math.sign(Number(time));\n        time = time.replace(/^-/, '');\n        const seconds = Number(time.substr(0, time.length - 9)) * sign;\n        const nanos = Number(time.substr(-9)) * sign;\n        this.setTime(seconds * 1000);\n        return this.setNanoseconds(nanos);\n    }\n    /**\n     * Sets the PreciseDate object to the time represented by a number of\n     * milliseconds since January 1, 1970, 00:00:00 UTC. Calling this method will\n     * reset both the microseconds and nanoseconds to 0.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime|Date#setTime}\n     *\n     * @param {number} time Value representing the number of milliseconds since\n     *     January 1, 1970, 00:00:00 UTC.\n     * @returns {string} The number of milliseconds between January 1, 1970,\n     *     00:00:00 UTC and the updated date (effectively, the value of the\n     *     argument).\n     */\n    setTime(time) {\n        this._micros = 0;\n        this._nanos = 0;\n        return super.setTime(time);\n    }\n    /**\n     * Returns a string in RFC 3339 format. Unlike the native `Date#toISOString`,\n     * this will return 9 digits to represent sub-second precision.\n     *\n     * @see {@link https://tools.ietf.org/html/rfc3339|RFC 3339}\n     *\n     * @returns {string}\n     *\n     * @example\n     * const date = new PreciseDate(1549622069481145231n);\n     *\n     * console.log(date.toISOString());\n     * // expected output: \"2019-02-08T10:34:29.481145231Z\"\n     */\n    toISOString() {\n        const micros = padLeft(this._micros, 3);\n        const nanos = padLeft(this._nanos, 3);\n        return super.toISOString().replace(/z$/i, `${micros}${nanos}Z`);\n    }\n    /**\n     * Returns an object representing the specified date according to universal\n     * time.\n     *\n     * @see {@link https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#timestamp|google.protobuf.Timestamp}\n     *\n     * @returns {DateStruct}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.toStruct());\n     * // expected output: {seconds: 1549622069, nanos: 481145231}\n     */\n    toStruct() {\n        let seconds = this._getSeconds();\n        const nanos = this._getNanos();\n        const sign = Math.sign(seconds);\n        // These objects are essentially a mirror of protobuf timestamps.\n        // `nanos` must always count forward in time, even if the date is <= Unix\n        // epoch. To do this we just need to count backwards 1 second and return the\n        // nanoseconds as is.\n        if (sign === Sign.NEGATIVE && nanos) {\n            seconds -= 1;\n        }\n        return { seconds, nanos };\n    }\n    /**\n     * Returns a tuple representing the specified date according to universal\n     * time.\n     *\n     * @returns {DateTuple}\n     *\n     * @example\n     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');\n     *\n     * console.log(date.toTuple());\n     * // expected output: [1549622069, 481145231]\n     */\n    toTuple() {\n        const { seconds, nanos } = this.toStruct();\n        return [seconds, nanos];\n    }\n    /**\n     * Returns the total number of seconds in the specified date since Unix epoch.\n     * Numbers representing < epoch will be negative.\n     *\n     * @private\n     *\n     * @returns {number}\n     */\n    _getSeconds() {\n        const time = this.getTime();\n        const sign = Math.sign(time);\n        return Math.floor(Math.abs(time) / 1000) * sign;\n    }\n    /**\n     * Returns the sub-second precision of the specified date. This will always be\n     * a positive number.\n     *\n     * @private\n     *\n     * @returns {number}\n     */\n    _getNanos() {\n        const msInNanos = this.getUTCMilliseconds() * 1e6;\n        const microsInNanos = this._micros * 1000;\n        return this._nanos + msInNanos + microsInNanos;\n    }\n    /**\n     * Parses a precise time.\n     *\n     * @static\n     *\n     * @param {string|bigint|DateTuple|DateStruct} time The precise time value.\n     * @returns {string} Returns a string representing the nanoseconds in the\n     *     specified date according to universal time.\n     *\n     * @example <caption>From a RFC 3339 formatted string.</caption>\n     * const time = PreciseDate.parseFull('2019-02-08T10:34:29.481145231Z');\n     * console.log(time); // expected output: \"1549622069481145231\"\n     *\n     * @example <caption>From a nanosecond timestamp string.</caption>\n     * const time = PreciseDate.parseFull('1549622069481145231');\n     * console.log(time); // expected output: \"1549622069481145231\"\n     *\n     * @example <caption>From a BigInt (requires Node >= v10.7)</caption>\n     * const time = PreciseDate.parseFull(1549622069481145231n);\n     * console.log(time); // expected output: \"1549622069481145231\"\n     *\n     * @example <caption>From a tuple.</caption>\n     * const time = PreciseDate.parseFull([1549622069, 481145231]);\n     * console.log(time); // expected output: \"1549622069481145231\"\n     *\n     * @example <caption>From an object.</caption>\n     * const struct = {seconds: 1549622069, nanos: 481145231};\n     * const time = PreciseDate.parseFull(struct);\n     * console.log(time); // expected output: \"1549622069481145231\"\n     */\n    static parseFull(time) {\n        const date = new PreciseDate();\n        if (Array.isArray(time)) {\n            const [seconds, nanos] = time;\n            time = { seconds, nanos };\n        }\n        if (isFullTime(time)) {\n            date.setFullTime(time);\n        }\n        else if (isStruct(time)) {\n            const { seconds, nanos } = parseProto(time);\n            date.setTime(seconds * 1000);\n            date.setNanoseconds(nanos);\n        }\n        else if (isFullISOString(time)) {\n            date.setFullTime(parseFullISO(time));\n        }\n        else {\n            date.setTime(new Date(time).getTime());\n        }\n        return date.getFullTimeString();\n    }\n    /**\n     * Accepts the same number parameters as the PreciseDate constructor, but\n     * treats them as UTC. It returns a string that represents the number of\n     * nanoseconds since January 1, 1970, 00:00:00 UTC.\n     *\n     * **NOTE:** Because this method returns a `BigInt` it requires Node >= v10.7.\n     *\n     * @see {@link https://github.com/tc39/proposal-bigint|BigInt}\n     *\n     * @static\n     *\n     * @throws {error} If `BigInt` is unavailable.\n     *\n     * @param {...number} [dateFields] The date fields.\n     * @returns {bigint}\n     *\n     * @example\n     * const time = PreciseDate.fullUTC(2019, 1, 8, 10, 34, 29, 481, 145, 231);\n     * console.log(time); // expected output: 1549622069481145231n\n     */\n    static fullUTC(...args) {\n        if (typeof BigInt !== 'function') {\n            throw new Error(NO_BIG_INT);\n        }\n        return BigInt(PreciseDate.fullUTCString(...args));\n    }\n    /**\n     * Accepts the same number parameters as the PreciseDate constructor, but\n     * treats them as UTC. It returns a string that represents the number of\n     * nanoseconds since January 1, 1970, 00:00:00 UTC.\n     *\n     * @static\n     *\n     * @param {...number} [dateFields] The date fields.\n     * @returns {string}\n     *\n     * @example\n     * const time = PreciseDate.fullUTCString(2019, 1, 8, 10, 34, 29, 481, 145,\n     * 231); console.log(time); // expected output: '1549622069481145231'\n     */\n    static fullUTCString(...args) {\n        const milliseconds = Date.UTC(...args.slice(0, 7));\n        const date = new PreciseDate(milliseconds);\n        if (args.length === 9) {\n            date.setNanoseconds(args.pop());\n        }\n        if (args.length === 8) {\n            date.setMicroseconds(args.pop());\n        }\n        return date.getFullTimeString();\n    }\n}\nexports.PreciseDate = PreciseDate;\n/**\n * Parses a RFC 3339 formatted string representation of the date, and returns\n * a string representing the nanoseconds since January 1, 1970, 00:00:00.\n *\n * @private\n *\n * @param {string} time The RFC 3339 formatted string.\n * @returns {string}\n */\nfunction parseFullISO(time) {\n    let digits = '0';\n    time = time.replace(/\\.(\\d+)/, ($0, $1) => {\n        digits = $1;\n        return '.000';\n    });\n    const nanos = Number(padRight(digits, 9));\n    const date = new PreciseDate(time);\n    return date.setNanoseconds(nanos);\n}\n/**\n * Normalizes a {@link google.protobuf.Timestamp} object.\n *\n * @private\n *\n * @param {google.protobuf.Timestamp} timestamp The timestamp object.\n * @returns {DateStruct}\n */\nfunction parseProto({ seconds = 0, nanos = 0 }) {\n    if (typeof seconds.toNumber === 'function') {\n        seconds = seconds.toNumber();\n    }\n    seconds = Number(seconds);\n    nanos = Number(nanos);\n    return { seconds, nanos };\n}\n/**\n * Checks to see if time value is specified in nanoseconds. We assume that all\n * BigInt and string timestamps represent nanoseconds.\n *\n * @private\n *\n * @param {*} time The time to check.\n * @returns {boolean}\n */\nfunction isFullTime(time) {\n    return (typeof time === 'bigint' || (typeof time === 'string' && /^\\d+$/.test(time)));\n}\n/**\n * Checks to see if time value is a {@link DateStruct}.\n *\n * @private\n *\n * @param {*} time The time to check.\n * @returns {boolean}\n */\nfunction isStruct(time) {\n    return ((typeof time === 'object' &&\n        typeof time.seconds !== 'undefined') ||\n        typeof time.nanos === 'number');\n}\n/**\n * Checks to see if the time value is a RFC 3339 formatted string.\n *\n * @private\n *\n * @param {*} time The time to check.\n * @returns {boolean}\n */\nfunction isFullISOString(time) {\n    return typeof time === 'string' && FULL_ISO_REG.test(time);\n}\n/**\n * Pads a number/string with \"0\" to the left.\n *\n * @private\n *\n * @param {string|number} n The number/string to pad.\n * @param {number} min The min size of the padded string.\n * @returns {string}\n */\nfunction padLeft(n, min) {\n    const padding = getPadding(n, min);\n    return `${padding}${n}`;\n}\n/**\n * Pads a number/string with \"0\" to the right.\n *\n * @private\n *\n * @param {string|number} n The number/string to pad.\n * @param {number} min The min size of the padded string.\n * @returns {string}\n */\nfunction padRight(n, min) {\n    const padding = getPadding(n, min);\n    return `${n}${padding}`;\n}\n/**\n * Creates padding based on current size and min size needed.\n *\n * @private\n *\n * @param {string|number} n The number/string to pad.\n * @param {number} [min=3] The min size of the padded string.\n * @returns {string}\n */\nfunction getPadding(n, min) {\n    const size = Math.max(min - n.toString().length, 0);\n    return '0'.repeat(size);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS1jbG91ZC9wcmVjaXNlLWRhdGUvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQix5QkFBeUIsRUFBRSw0Q0FBNEMsSUFBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdEQUFnRDtBQUMzRDtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0NBQXNDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQ7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVEsRUFBRSxFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRSxFQUFFLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9hbGJlcnRvL0RvY3VtZW50b3MvRGVzZW52b2x2aW1lbnRvIFdlYi9Sb2NrZXRzZWF0L1RyaWdnZXJEZXYvbm9kZV9tb2R1bGVzL0Bnb29nbGUtY2xvdWQvcHJlY2lzZS1kYXRlL2J1aWxkL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByZWNpc2VEYXRlID0gdm9pZCAwO1xuY29uc3QgRlVMTF9JU09fUkVHID0gL1xcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkXFwuXFxkezQsOX1aLztcbmNvbnN0IE5PX0JJR19JTlQgPSAnQmlnSW50IG9ubHkgYXZhaWxhYmxlIGluIE5vZGUgPj0gdjEwLjcuIENvbnNpZGVyIHVzaW5nIGdldEZ1bGxUaW1lU3RyaW5nIGluc3RlYWQuJztcbnZhciBTaWduO1xuKGZ1bmN0aW9uIChTaWduKSB7XG4gICAgU2lnbltTaWduW1wiTkVHQVRJVkVcIl0gPSAtMV0gPSBcIk5FR0FUSVZFXCI7XG4gICAgU2lnbltTaWduW1wiUE9TSVRJVkVcIl0gPSAxXSA9IFwiUE9TSVRJVkVcIjtcbiAgICBTaWduW1NpZ25bXCJaRVJPXCJdID0gMF0gPSBcIlpFUk9cIjtcbn0pKFNpZ24gfHwgKFNpZ24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgbmF0aXZlIERhdGUgb2JqZWN0LlxuICogQGV4dGVybmFsIERhdGVcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGV9XG4gKi9cbi8qKlxuICogQHR5cGVkZWYge2FycmF5fSBEYXRlVHVwbGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAwIFJlcHJlc2VudHMgc2Vjb25kcyBvZiBVVEMgdGltZSBzaW5jZSBVbml4IGVwb2NoXG4gKiAgICAgMTk3MC0wMS0wMVQwMDowMDowMFouIE11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0b1xuICogICAgIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAxIE5vbi1uZWdhdGl2ZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZFxuICogICAgIHJlc29sdXRpb24uIE5lZ2F0aXZlIHNlY29uZCB2YWx1ZXMgd2l0aCBmcmFjdGlvbnMgbXVzdCBzdGlsbCBoYXZlXG4gKiAgICAgbm9uLW5lZ2F0aXZlIG5hbm9zIHZhbHVlcyB0aGF0IGNvdW50IGZvcndhcmQgaW4gdGltZS4gTXVzdCBiZSBmcm9tIDAgdG9cbiAqICAgICA5OTksOTk5LDk5OSBpbmNsdXNpdmUuXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gRGF0ZVN0cnVjdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNlY29uZHMgUmVwcmVzZW50cyBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2hcbiAqICAgICAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXG4gKiAgICAgOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG5hbm9zIE5vbi1uZWdhdGl2ZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZFxuICogICAgIHJlc29sdXRpb24uIE5lZ2F0aXZlIHNlY29uZCB2YWx1ZXMgd2l0aCBmcmFjdGlvbnMgbXVzdCBzdGlsbCBoYXZlXG4gKiAgICAgbm9uLW5lZ2F0aXZlIG5hbm9zIHZhbHVlcyB0aGF0IGNvdW50IGZvcndhcmQgaW4gdGltZS4gTXVzdCBiZSBmcm9tIDAgdG9cbiAqICAgICA5OTksOTk5LDk5OSBpbmNsdXNpdmUuXG4gKi9cbi8qKlxuICogRGF0ZSBvYmplY3Qgd2l0aCBuYW5vc2Vjb25kIHByZWNpc2lvbi4gU3VwcG9ydHMgYWxsIHN0YW5kYXJkIERhdGUgYXJndW1lbnRzXG4gKiBpbiBhZGRpdGlvbiB0byBzZXZlcmFsIGN1c3RvbSB0eXBlcyBhcyBub3RlZCBiZWxvdy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIGV4dGVybmFsOkRhdGVcbiAqXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8YmlnaW50fERhdGV8RGF0ZVR1cGxlfERhdGVTdHJ1Y3R9IFt0aW1lXSBUaGUgdGltZVxuICogICAgIHZhbHVlLlxuICogQHBhcmFtIHsuLi5udW1iZXJ9IFtkYXRlRmllbGRzXSBBZGRpdGlvbmFsIGRhdGUgZmllbGRzIChtb250aCwgZGF0ZSwgaG91cnMsXG4gKiAgICAgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBtaWNyb3NlY29uZHMsIG5hbm9zZWNvbmRzKS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5XaXRoIGEgUkZDIDMzMzkgZm9ybWF0dGVkIHN0cmluZy48L2NhcHRpb24+XG4gKiBjb25zdCBkYXRlID0gbmV3IFByZWNpc2VEYXRlKCcyMDE5LTAyLTA4VDEwOjM0OjI5LjQ4MTE0NTIzMVonKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5XaXRoIGEgbmFub3NlY29uZCB0aW1lc3RhbXAgc3RyaW5nLjwvY2FwdGlvbj5cbiAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoJzE1NDk2MjIwNjk0ODEzMjAwMzInKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5XaXRoIGEgQmlnSW50IChyZXF1aXJlcyBOb2RlID49IHYxMC43KTwvY2FwdGlvbj5cbiAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoMTU0OTYyMjA2OTQ4MTMyMDAzMm4pO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPldpdGggYSB0dXBsZSBjb250YWluaW5nIHNlY29uZHMgYW5kIG5hbm9zZWNvbmRzLjwvY2FwdGlvbj5cbiAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoWzE1NDk2MjIwNjksIDQ4MTMyMDAzMl0pO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPldpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgYHNlY29uZHNgIGFuZCBgbmFub3NgPC9jYXB0aW9uPlxuICogY29uc3QgZGF0ZSA9IG5ldyBQcmVjaXNlRGF0ZSh7c2Vjb25kczogMTU0OTYyMjA2OSwgbmFub3M6IDQ4MTMyMDAzMn0pO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlNwZWNpZml5aW5nIGRhdGUgZmllbGRzPC9jYXB0aW9uPlxuICogY29uc3QgZGF0ZSA9IG5ldyBQcmVjaXNlRGF0ZSgyMDE4LCA1LCAxNCwgNDEsIDExLCAzNCwgMTIzLCA4NzQsIDMyMSk7XG4gKi9cbmNsYXNzIFByZWNpc2VEYXRlIGV4dGVuZHMgRGF0ZSB7XG4gICAgY29uc3RydWN0b3IodGltZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9taWNyb3MgPSAwO1xuICAgICAgICB0aGlzLl9uYW5vcyA9IDA7XG4gICAgICAgIGlmICh0aW1lICYmIHR5cGVvZiB0aW1lICE9PSAnbnVtYmVyJyAmJiAhKHRpbWUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRGdWxsVGltZShQcmVjaXNlRGF0ZS5wYXJzZUZ1bGwodGltZSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgICAgICAgY29uc3QgZGF0ZUZpZWxkcyA9IGFyZ3Muc2xpY2UoMCwgNyk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSguLi5kYXRlRmllbGRzKTtcbiAgICAgICAgY29uc3QgbmFub3MgPSBhcmdzLmxlbmd0aCA9PT0gOSA/IGFyZ3MucG9wKCkgOiAwO1xuICAgICAgICBjb25zdCBtaWNyb3MgPSBhcmdzLmxlbmd0aCA9PT0gOCA/IGFyZ3MucG9wKCkgOiAwO1xuICAgICAgICB0aGlzLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICB0aGlzLnNldE1pY3Jvc2Vjb25kcyhtaWNyb3MpO1xuICAgICAgICB0aGlzLnNldE5hbm9zZWNvbmRzKG5hbm9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIGRhdGUgcmVwcmVzZW50ZWQgaW4gbmFub3NlY29uZHMgYWNjb3JkaW5nIHRvXG4gICAgICogdW5pdmVyc2FsIHRpbWUuXG4gICAgICpcbiAgICAgKiAqKk5PVEU6KiogQmVjYXVzZSB0aGlzIG1ldGhvZCByZXR1cm5zIGEgYEJpZ0ludGAgaXQgcmVxdWlyZXMgTm9kZSA+PSB2MTAuNy5cbiAgICAgKiBVc2Uge0BsaW5rIFByZWNpc2VEYXRlI2dldEZ1bGxUaW1lU3RyaW5nfSB0byBnZXQgdGhlIHRpbWUgYXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1iaWdpbnR8QmlnSW50fVxuICAgICAqXG4gICAgICogQHRocm93cyB7ZXJyb3J9IElmIGBCaWdJbnRgIGlzIHVuYXZhaWxhYmxlLlxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoJzIwMTktMDItMDhUMTA6MzQ6MjkuNDgxMTQ1MjMxWicpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZGF0ZS5nZXRGdWxsVGltZSgpKTtcbiAgICAgKiAvLyBleHBlY3RlZCBvdXRwdXQ6IDE1NDk2MjIwNjk0ODExNDUyMzFuXG4gICAgICovXG4gICAgZ2V0RnVsbFRpbWUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgQmlnSW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTk9fQklHX0lOVCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLmdldEZ1bGxUaW1lU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIG9mIHRoZSBzcGVjaWZpZWQgZGF0ZSByZXByZXNlbnRlZCBpbiBuYW5vc2Vjb25kcyBhY2NvcmRpbmdcbiAgICAgKiB0byB1bml2ZXJzYWwgdGltZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoJzIwMTktMDItMDhUMTA6MzQ6MjkuNDgxMTQ1MjMxWicpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZGF0ZS5nZXRGdWxsVGltZVN0cmluZygpKTtcbiAgICAgKiAvLyBleHBlY3RlZCBvdXRwdXQ6IFwiMTU0OTYyMjA2OTQ4MTE0NTIzMVwiXG4gICAgICovXG4gICAgZ2V0RnVsbFRpbWVTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSB0aGlzLl9nZXRTZWNvbmRzKCk7XG4gICAgICAgIGxldCBuYW5vcyA9IHRoaXMuX2dldE5hbm9zKCk7XG4gICAgICAgIGlmIChuYW5vcyAmJiBNYXRoLnNpZ24oc2Vjb25kcykgPT09IFNpZ24uTkVHQVRJVkUpIHtcbiAgICAgICAgICAgIG5hbm9zID0gMWU5IC0gbmFub3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3NlY29uZHN9JHtwYWRMZWZ0KG5hbm9zLCA5KX1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtaWNyb3NlY29uZHMgaW4gdGhlIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byB1bml2ZXJzYWwgdGltZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoJzIwMTktMDItMDhUMTA6MzQ6MjkuNDgxMTQ1WicpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZGF0ZS5nZXRNaWNyb3NlY29uZHMoKSk7XG4gICAgICogLy8gZXhwZWN0ZWQgb3V0cHV0OiAxNDVcbiAgICAgKi9cbiAgICBnZXRNaWNyb3NlY29uZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taWNyb3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbm9zZWNvbmRzIGluIHRoZSBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gdW5pdmVyc2FsIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBkYXRlID0gbmV3IFByZWNpc2VEYXRlKCcyMDE5LTAyLTA4VDEwOjM0OjI5LjQ4MTE0NTIzMVonKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGRhdGUuZ2V0TmFub3NlY29uZHMoKSk7XG4gICAgICogLy8gZXhwZWN0ZWQgb3V0cHV0OiAyMzFcbiAgICAgKi9cbiAgICBnZXROYW5vc2Vjb25kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbm9zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtaWNyb3NlY29uZHMgZm9yIGEgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIHVuaXZlcnNhbCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pY3Jvc2Vjb25kcyBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIG1pY3Jvc2Vjb25kcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmFub3NlY29uZHMgaW4gdGhlXG4gICAgICogICAgIHNwZWNpZmllZCBkYXRlIGFjY29yZGluZyB0byB1bml2ZXJzYWwgdGltZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgZGF0ZSA9IG5ldyBQcmVjaXNlRGF0ZSgpO1xuICAgICAqXG4gICAgICogZGF0ZS5zZXRNaWNyb3NlY29uZHMoMTQ5KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGRhdGUuZ2V0TWljcm9zZWNvbmRzKCkpO1xuICAgICAqIC8vIGV4cGVjdGVkIG91dHB1dDogMTQ5XG4gICAgICovXG4gICAgc2V0TWljcm9zZWNvbmRzKG1pY3Jvcykge1xuICAgICAgICBjb25zdCBhYnMgPSBNYXRoLmFicyhtaWNyb3MpO1xuICAgICAgICBsZXQgbWlsbGlzID0gdGhpcy5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgaWYgKGFicyA+PSAxMDAwKSB7XG4gICAgICAgICAgICBtaWxsaXMgKz0gTWF0aC5mbG9vcihhYnMgLyAxMDAwKSAqIE1hdGguc2lnbihtaWNyb3MpO1xuICAgICAgICAgICAgbWljcm9zICU9IDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguc2lnbihtaWNyb3MpID09PSBTaWduLk5FR0FUSVZFKSB7XG4gICAgICAgICAgICBtaWxsaXMgLT0gMTtcbiAgICAgICAgICAgIG1pY3JvcyArPSAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21pY3JvcyA9IG1pY3JvcztcbiAgICAgICAgdGhpcy5zZXRVVENNaWxsaXNlY29uZHMobWlsbGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RnVsbFRpbWVTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbmFub3NlY29uZHMgZm9yIGEgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIHVuaXZlcnNhbCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5hbm9zZWNvbmRzIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbmFub3NlY29uZHMuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbm9zZWNvbmRzIGluIHRoZVxuICAgICAqICAgICBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gdW5pdmVyc2FsIHRpbWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoKTtcbiAgICAgKlxuICAgICAqIGRhdGUuc2V0TmFub3NlY29uZHMoMjMxKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGRhdGUuZ2V0TmFub3NlY29uZHMoKSk7XG4gICAgICogLy8gZXhwZWN0ZWQgb3V0cHV0OiAyMzFcbiAgICAgKi9cbiAgICBzZXROYW5vc2Vjb25kcyhuYW5vcykge1xuICAgICAgICBjb25zdCBhYnMgPSBNYXRoLmFicyhuYW5vcyk7XG4gICAgICAgIGxldCBtaWNyb3MgPSB0aGlzLl9taWNyb3M7XG4gICAgICAgIGlmIChhYnMgPj0gMTAwMCkge1xuICAgICAgICAgICAgbWljcm9zICs9IE1hdGguZmxvb3IoYWJzIC8gMTAwMCkgKiBNYXRoLnNpZ24obmFub3MpO1xuICAgICAgICAgICAgbmFub3MgJT0gMTAwMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5zaWduKG5hbm9zKSA9PT0gU2lnbi5ORUdBVElWRSkge1xuICAgICAgICAgICAgbWljcm9zIC09IDE7XG4gICAgICAgICAgICBuYW5vcyArPSAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25hbm9zID0gbmFub3M7XG4gICAgICAgIHJldHVybiB0aGlzLnNldE1pY3Jvc2Vjb25kcyhtaWNyb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBQcmVjaXNlRGF0ZSBvYmplY3QgdG8gdGhlIHRpbWUgcmVwcmVzZW50ZWQgYnkgYSBudW1iZXIgb2ZcbiAgICAgKiBuYW5vc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAsIDAwOjAwOjAwIFVUQy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YmlnaW50fG51bWJlcnxzdHJpbmd9IHRpbWUgVmFsdWUgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2ZcbiAgICAgKiAgICAgbmFub3NlY29uZHMgc2luY2UgSmFudWFyeSAxLCAxOTcwLCAwMDowMDowMCBVVEMuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbm9zZWNvbmRzIGluIHRoZVxuICAgICAqICAgICBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gdW5pdmVyc2FsIHRpbWUgKGVmZmVjdGl2ZWx5LCB0aGUgdmFsdWUgb2ZcbiAgICAgKiAgICAgdGhlIGFyZ3VtZW50KS5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWJpZ2ludHxCaWdJbnR9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5XaXRoIGEgbmFub3NlY29uZCBzdHJpbmcuPC9jYXB0aW9uPlxuICAgICAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoKTtcbiAgICAgKiBkYXRlLnNldEZ1bGxUaW1lKCcxNTQ5NjIyMDY5NDgxMTQ1MjMxJyk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5XaXRoIGEgQmlnSW50PC9jYXB0aW9uPlxuICAgICAqIGRhdGUuc2V0RnVsbFRpbWUoMTU0OTYyMjA2OTQ4MTE0NTIzMW4pO1xuICAgICAqL1xuICAgIHNldEZ1bGxUaW1lKHRpbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGltZSA9IHRpbWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduID0gTWF0aC5zaWduKE51bWJlcih0aW1lKSk7XG4gICAgICAgIHRpbWUgPSB0aW1lLnJlcGxhY2UoL14tLywgJycpO1xuICAgICAgICBjb25zdCBzZWNvbmRzID0gTnVtYmVyKHRpbWUuc3Vic3RyKDAsIHRpbWUubGVuZ3RoIC0gOSkpICogc2lnbjtcbiAgICAgICAgY29uc3QgbmFub3MgPSBOdW1iZXIodGltZS5zdWJzdHIoLTkpKSAqIHNpZ247XG4gICAgICAgIHRoaXMuc2V0VGltZShzZWNvbmRzICogMTAwMCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNldE5hbm9zZWNvbmRzKG5hbm9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUHJlY2lzZURhdGUgb2JqZWN0IHRvIHRoZSB0aW1lIHJlcHJlc2VudGVkIGJ5IGEgbnVtYmVyIG9mXG4gICAgICogbWlsbGlzZWNvbmRzIHNpbmNlIEphbnVhcnkgMSwgMTk3MCwgMDA6MDA6MDAgVVRDLiBDYWxsaW5nIHRoaXMgbWV0aG9kIHdpbGxcbiAgICAgKiByZXNldCBib3RoIHRoZSBtaWNyb3NlY29uZHMgYW5kIG5hbm9zZWNvbmRzIHRvIDAuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3NldFRpbWV8RGF0ZSNzZXRUaW1lfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgVmFsdWUgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlXG4gICAgICogICAgIEphbnVhcnkgMSwgMTk3MCwgMDA6MDA6MDAgVVRDLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGJldHdlZW4gSmFudWFyeSAxLCAxOTcwLFxuICAgICAqICAgICAwMDowMDowMCBVVEMgYW5kIHRoZSB1cGRhdGVkIGRhdGUgKGVmZmVjdGl2ZWx5LCB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICogICAgIGFyZ3VtZW50KS5cbiAgICAgKi9cbiAgICBzZXRUaW1lKHRpbWUpIHtcbiAgICAgICAgdGhpcy5fbWljcm9zID0gMDtcbiAgICAgICAgdGhpcy5fbmFub3MgPSAwO1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0VGltZSh0aW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBpbiBSRkMgMzMzOSBmb3JtYXQuIFVubGlrZSB0aGUgbmF0aXZlIGBEYXRlI3RvSVNPU3RyaW5nYCxcbiAgICAgKiB0aGlzIHdpbGwgcmV0dXJuIDkgZGlnaXRzIHRvIHJlcHJlc2VudCBzdWItc2Vjb25kIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5fFJGQyAzMzM5fVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgZGF0ZSA9IG5ldyBQcmVjaXNlRGF0ZSgxNTQ5NjIyMDY5NDgxMTQ1MjMxbik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhkYXRlLnRvSVNPU3RyaW5nKCkpO1xuICAgICAqIC8vIGV4cGVjdGVkIG91dHB1dDogXCIyMDE5LTAyLTA4VDEwOjM0OjI5LjQ4MTE0NTIzMVpcIlxuICAgICAqL1xuICAgIHRvSVNPU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBtaWNyb3MgPSBwYWRMZWZ0KHRoaXMuX21pY3JvcywgMyk7XG4gICAgICAgIGNvbnN0IG5hbm9zID0gcGFkTGVmdCh0aGlzLl9uYW5vcywgMyk7XG4gICAgICAgIHJldHVybiBzdXBlci50b0lTT1N0cmluZygpLnJlcGxhY2UoL3okL2ksIGAke21pY3Jvc30ke25hbm9zfVpgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gdW5pdmVyc2FsXG4gICAgICogdGltZS5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9yZWZlcmVuY2UvZ29vZ2xlLnByb3RvYnVmI3RpbWVzdGFtcHxnb29nbGUucHJvdG9idWYuVGltZXN0YW1wfVxuICAgICAqXG4gICAgICogQHJldHVybnMge0RhdGVTdHJ1Y3R9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoJzIwMTktMDItMDhUMTA6MzQ6MjkuNDgxMTQ1MjMxWicpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZGF0ZS50b1N0cnVjdCgpKTtcbiAgICAgKiAvLyBleHBlY3RlZCBvdXRwdXQ6IHtzZWNvbmRzOiAxNTQ5NjIyMDY5LCBuYW5vczogNDgxMTQ1MjMxfVxuICAgICAqL1xuICAgIHRvU3RydWN0KCkge1xuICAgICAgICBsZXQgc2Vjb25kcyA9IHRoaXMuX2dldFNlY29uZHMoKTtcbiAgICAgICAgY29uc3QgbmFub3MgPSB0aGlzLl9nZXROYW5vcygpO1xuICAgICAgICBjb25zdCBzaWduID0gTWF0aC5zaWduKHNlY29uZHMpO1xuICAgICAgICAvLyBUaGVzZSBvYmplY3RzIGFyZSBlc3NlbnRpYWxseSBhIG1pcnJvciBvZiBwcm90b2J1ZiB0aW1lc3RhbXBzLlxuICAgICAgICAvLyBgbmFub3NgIG11c3QgYWx3YXlzIGNvdW50IGZvcndhcmQgaW4gdGltZSwgZXZlbiBpZiB0aGUgZGF0ZSBpcyA8PSBVbml4XG4gICAgICAgIC8vIGVwb2NoLiBUbyBkbyB0aGlzIHdlIGp1c3QgbmVlZCB0byBjb3VudCBiYWNrd2FyZHMgMSBzZWNvbmQgYW5kIHJldHVybiB0aGVcbiAgICAgICAgLy8gbmFub3NlY29uZHMgYXMgaXMuXG4gICAgICAgIGlmIChzaWduID09PSBTaWduLk5FR0FUSVZFICYmIG5hbm9zKSB7XG4gICAgICAgICAgICBzZWNvbmRzIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHR1cGxlIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIGRhdGUgYWNjb3JkaW5nIHRvIHVuaXZlcnNhbFxuICAgICAqIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RGF0ZVR1cGxlfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBkYXRlID0gbmV3IFByZWNpc2VEYXRlKCcyMDE5LTAyLTA4VDEwOjM0OjI5LjQ4MTE0NTIzMVonKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGRhdGUudG9UdXBsZSgpKTtcbiAgICAgKiAvLyBleHBlY3RlZCBvdXRwdXQ6IFsxNTQ5NjIyMDY5LCA0ODExNDUyMzFdXG4gICAgICovXG4gICAgdG9UdXBsZSgpIHtcbiAgICAgICAgY29uc3QgeyBzZWNvbmRzLCBuYW5vcyB9ID0gdGhpcy50b1N0cnVjdCgpO1xuICAgICAgICByZXR1cm4gW3NlY29uZHMsIG5hbm9zXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIHNlY29uZHMgaW4gdGhlIHNwZWNpZmllZCBkYXRlIHNpbmNlIFVuaXggZXBvY2guXG4gICAgICogTnVtYmVycyByZXByZXNlbnRpbmcgPCBlcG9jaCB3aWxsIGJlIG5lZ2F0aXZlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgX2dldFNlY29uZHMoKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3Qgc2lnbiA9IE1hdGguc2lnbih0aW1lKTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5hYnModGltZSkgLyAxMDAwKSAqIHNpZ247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN1Yi1zZWNvbmQgcHJlY2lzaW9uIG9mIHRoZSBzcGVjaWZpZWQgZGF0ZS4gVGhpcyB3aWxsIGFsd2F5cyBiZVxuICAgICAqIGEgcG9zaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgX2dldE5hbm9zKCkge1xuICAgICAgICBjb25zdCBtc0luTmFub3MgPSB0aGlzLmdldFVUQ01pbGxpc2Vjb25kcygpICogMWU2O1xuICAgICAgICBjb25zdCBtaWNyb3NJbk5hbm9zID0gdGhpcy5fbWljcm9zICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbm9zICsgbXNJbk5hbm9zICsgbWljcm9zSW5OYW5vcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgcHJlY2lzZSB0aW1lLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8YmlnaW50fERhdGVUdXBsZXxEYXRlU3RydWN0fSB0aW1lIFRoZSBwcmVjaXNlIHRpbWUgdmFsdWUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbm9zZWNvbmRzIGluIHRoZVxuICAgICAqICAgICBzcGVjaWZpZWQgZGF0ZSBhY2NvcmRpbmcgdG8gdW5pdmVyc2FsIHRpbWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Gcm9tIGEgUkZDIDMzMzkgZm9ybWF0dGVkIHN0cmluZy48L2NhcHRpb24+XG4gICAgICogY29uc3QgdGltZSA9IFByZWNpc2VEYXRlLnBhcnNlRnVsbCgnMjAxOS0wMi0wOFQxMDozNDoyOS40ODExNDUyMzFaJyk7XG4gICAgICogY29uc29sZS5sb2codGltZSk7IC8vIGV4cGVjdGVkIG91dHB1dDogXCIxNTQ5NjIyMDY5NDgxMTQ1MjMxXCJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkZyb20gYSBuYW5vc2Vjb25kIHRpbWVzdGFtcCBzdHJpbmcuPC9jYXB0aW9uPlxuICAgICAqIGNvbnN0IHRpbWUgPSBQcmVjaXNlRGF0ZS5wYXJzZUZ1bGwoJzE1NDk2MjIwNjk0ODExNDUyMzEnKTtcbiAgICAgKiBjb25zb2xlLmxvZyh0aW1lKTsgLy8gZXhwZWN0ZWQgb3V0cHV0OiBcIjE1NDk2MjIwNjk0ODExNDUyMzFcIlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RnJvbSBhIEJpZ0ludCAocmVxdWlyZXMgTm9kZSA+PSB2MTAuNyk8L2NhcHRpb24+XG4gICAgICogY29uc3QgdGltZSA9IFByZWNpc2VEYXRlLnBhcnNlRnVsbCgxNTQ5NjIyMDY5NDgxMTQ1MjMxbik7XG4gICAgICogY29uc29sZS5sb2codGltZSk7IC8vIGV4cGVjdGVkIG91dHB1dDogXCIxNTQ5NjIyMDY5NDgxMTQ1MjMxXCJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkZyb20gYSB0dXBsZS48L2NhcHRpb24+XG4gICAgICogY29uc3QgdGltZSA9IFByZWNpc2VEYXRlLnBhcnNlRnVsbChbMTU0OTYyMjA2OSwgNDgxMTQ1MjMxXSk7XG4gICAgICogY29uc29sZS5sb2codGltZSk7IC8vIGV4cGVjdGVkIG91dHB1dDogXCIxNTQ5NjIyMDY5NDgxMTQ1MjMxXCJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkZyb20gYW4gb2JqZWN0LjwvY2FwdGlvbj5cbiAgICAgKiBjb25zdCBzdHJ1Y3QgPSB7c2Vjb25kczogMTU0OTYyMjA2OSwgbmFub3M6IDQ4MTE0NTIzMX07XG4gICAgICogY29uc3QgdGltZSA9IFByZWNpc2VEYXRlLnBhcnNlRnVsbChzdHJ1Y3QpO1xuICAgICAqIGNvbnNvbGUubG9nKHRpbWUpOyAvLyBleHBlY3RlZCBvdXRwdXQ6IFwiMTU0OTYyMjA2OTQ4MTE0NTIzMVwiXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlRnVsbCh0aW1lKSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGltZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtzZWNvbmRzLCBuYW5vc10gPSB0aW1lO1xuICAgICAgICAgICAgdGltZSA9IHsgc2Vjb25kcywgbmFub3MgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdWxsVGltZSh0aW1lKSkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsVGltZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1N0cnVjdCh0aW1lKSkge1xuICAgICAgICAgICAgY29uc3QgeyBzZWNvbmRzLCBuYW5vcyB9ID0gcGFyc2VQcm90byh0aW1lKTtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZShzZWNvbmRzICogMTAwMCk7XG4gICAgICAgICAgICBkYXRlLnNldE5hbm9zZWNvbmRzKG5hbm9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Z1bGxJU09TdHJpbmcodGltZSkpIHtcbiAgICAgICAgICAgIGRhdGUuc2V0RnVsbFRpbWUocGFyc2VGdWxsSVNPKHRpbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZShuZXcgRGF0ZSh0aW1lKS5nZXRUaW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlLmdldEZ1bGxUaW1lU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgdGhlIHNhbWUgbnVtYmVyIHBhcmFtZXRlcnMgYXMgdGhlIFByZWNpc2VEYXRlIGNvbnN0cnVjdG9yLCBidXRcbiAgICAgKiB0cmVhdHMgdGhlbSBhcyBVVEMuIEl0IHJldHVybnMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBuYW5vc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAsIDAwOjAwOjAwIFVUQy5cbiAgICAgKlxuICAgICAqICoqTk9URToqKiBCZWNhdXNlIHRoaXMgbWV0aG9kIHJldHVybnMgYSBgQmlnSW50YCBpdCByZXF1aXJlcyBOb2RlID49IHYxMC43LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYmlnaW50fEJpZ0ludH1cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge2Vycm9yfSBJZiBgQmlnSW50YCBpcyB1bmF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4ubnVtYmVyfSBbZGF0ZUZpZWxkc10gVGhlIGRhdGUgZmllbGRzLlxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHRpbWUgPSBQcmVjaXNlRGF0ZS5mdWxsVVRDKDIwMTksIDEsIDgsIDEwLCAzNCwgMjksIDQ4MSwgMTQ1LCAyMzEpO1xuICAgICAqIGNvbnNvbGUubG9nKHRpbWUpOyAvLyBleHBlY3RlZCBvdXRwdXQ6IDE1NDk2MjIwNjk0ODExNDUyMzFuXG4gICAgICovXG4gICAgc3RhdGljIGZ1bGxVVEMoLi4uYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIEJpZ0ludCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE5PX0JJR19JTlQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQoUHJlY2lzZURhdGUuZnVsbFVUQ1N0cmluZyguLi5hcmdzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgdGhlIHNhbWUgbnVtYmVyIHBhcmFtZXRlcnMgYXMgdGhlIFByZWNpc2VEYXRlIGNvbnN0cnVjdG9yLCBidXRcbiAgICAgKiB0cmVhdHMgdGhlbSBhcyBVVEMuIEl0IHJldHVybnMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBuYW5vc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAsIDAwOjAwOjAwIFVUQy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4ubnVtYmVyfSBbZGF0ZUZpZWxkc10gVGhlIGRhdGUgZmllbGRzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHRpbWUgPSBQcmVjaXNlRGF0ZS5mdWxsVVRDU3RyaW5nKDIwMTksIDEsIDgsIDEwLCAzNCwgMjksIDQ4MSwgMTQ1LFxuICAgICAqIDIzMSk7IGNvbnNvbGUubG9nKHRpbWUpOyAvLyBleHBlY3RlZCBvdXRwdXQ6ICcxNTQ5NjIyMDY5NDgxMTQ1MjMxJ1xuICAgICAqL1xuICAgIHN0YXRpYyBmdWxsVVRDU3RyaW5nKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmRzID0gRGF0ZS5VVEMoLi4uYXJncy5zbGljZSgwLCA3KSk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUobWlsbGlzZWNvbmRzKTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSA5KSB7XG4gICAgICAgICAgICBkYXRlLnNldE5hbm9zZWNvbmRzKGFyZ3MucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRNaWNyb3NlY29uZHMoYXJncy5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFRpbWVTdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLlByZWNpc2VEYXRlID0gUHJlY2lzZURhdGU7XG4vKipcbiAqIFBhcnNlcyBhIFJGQyAzMzM5IGZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRhdGUsIGFuZCByZXR1cm5zXG4gKiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbm9zZWNvbmRzIHNpbmNlIEphbnVhcnkgMSwgMTk3MCwgMDA6MDA6MDAuXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGltZSBUaGUgUkZDIDMzMzkgZm9ybWF0dGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlRnVsbElTTyh0aW1lKSB7XG4gICAgbGV0IGRpZ2l0cyA9ICcwJztcbiAgICB0aW1lID0gdGltZS5yZXBsYWNlKC9cXC4oXFxkKykvLCAoJDAsICQxKSA9PiB7XG4gICAgICAgIGRpZ2l0cyA9ICQxO1xuICAgICAgICByZXR1cm4gJy4wMDAnO1xuICAgIH0pO1xuICAgIGNvbnN0IG5hbm9zID0gTnVtYmVyKHBhZFJpZ2h0KGRpZ2l0cywgOSkpO1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgUHJlY2lzZURhdGUodGltZSk7XG4gICAgcmV0dXJuIGRhdGUuc2V0TmFub3NlY29uZHMobmFub3MpO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIGEge0BsaW5rIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXB9IG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Z29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcH0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAgb2JqZWN0LlxuICogQHJldHVybnMge0RhdGVTdHJ1Y3R9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlUHJvdG8oeyBzZWNvbmRzID0gMCwgbmFub3MgPSAwIH0pIHtcbiAgICBpZiAodHlwZW9mIHNlY29uZHMudG9OdW1iZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgc2Vjb25kcyA9IE51bWJlcihzZWNvbmRzKTtcbiAgICBuYW5vcyA9IE51bWJlcihuYW5vcyk7XG4gICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcbn1cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aW1lIHZhbHVlIGlzIHNwZWNpZmllZCBpbiBuYW5vc2Vjb25kcy4gV2UgYXNzdW1lIHRoYXQgYWxsXG4gKiBCaWdJbnQgYW5kIHN0cmluZyB0aW1lc3RhbXBzIHJlcHJlc2VudCBuYW5vc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdGltZSBUaGUgdGltZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Z1bGxUaW1lKHRpbWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB0aW1lID09PSAnYmlnaW50JyB8fCAodHlwZW9mIHRpbWUgPT09ICdzdHJpbmcnICYmIC9eXFxkKyQvLnRlc3QodGltZSkpKTtcbn1cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aW1lIHZhbHVlIGlzIGEge0BsaW5rIERhdGVTdHJ1Y3R9LlxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHsqfSB0aW1lIFRoZSB0aW1lIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3RydWN0KHRpbWUpIHtcbiAgICByZXR1cm4gKCh0eXBlb2YgdGltZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIHRpbWUuc2Vjb25kcyAhPT0gJ3VuZGVmaW5lZCcpIHx8XG4gICAgICAgIHR5cGVvZiB0aW1lLm5hbm9zID09PSAnbnVtYmVyJyk7XG59XG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHRpbWUgdmFsdWUgaXMgYSBSRkMgMzMzOSBmb3JtYXR0ZWQgc3RyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHsqfSB0aW1lIFRoZSB0aW1lIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRnVsbElTT1N0cmluZyh0aW1lKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aW1lID09PSAnc3RyaW5nJyAmJiBGVUxMX0lTT19SRUcudGVzdCh0aW1lKTtcbn1cbi8qKlxuICogUGFkcyBhIG51bWJlci9zdHJpbmcgd2l0aCBcIjBcIiB0byB0aGUgbGVmdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbiBUaGUgbnVtYmVyL3N0cmluZyB0byBwYWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW4gc2l6ZSBvZiB0aGUgcGFkZGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHBhZExlZnQobiwgbWluKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IGdldFBhZGRpbmcobiwgbWluKTtcbiAgICByZXR1cm4gYCR7cGFkZGluZ30ke259YDtcbn1cbi8qKlxuICogUGFkcyBhIG51bWJlci9zdHJpbmcgd2l0aCBcIjBcIiB0byB0aGUgcmlnaHQuXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG4gVGhlIG51bWJlci9zdHJpbmcgdG8gcGFkLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluIHNpemUgb2YgdGhlIHBhZGRlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBwYWRSaWdodChuLCBtaW4pIHtcbiAgICBjb25zdCBwYWRkaW5nID0gZ2V0UGFkZGluZyhuLCBtaW4pO1xuICAgIHJldHVybiBgJHtufSR7cGFkZGluZ31gO1xufVxuLyoqXG4gKiBDcmVhdGVzIHBhZGRpbmcgYmFzZWQgb24gY3VycmVudCBzaXplIGFuZCBtaW4gc2l6ZSBuZWVkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG4gVGhlIG51bWJlci9zdHJpbmcgdG8gcGFkLlxuICogQHBhcmFtIHtudW1iZXJ9IFttaW49M10gVGhlIG1pbiBzaXplIG9mIHRoZSBwYWRkZWQgc3RyaW5nLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0UGFkZGluZyhuLCBtaW4pIHtcbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgobWluIC0gbi50b1N0cmluZygpLmxlbmd0aCwgMCk7XG4gICAgcmV0dXJuICcwJy5yZXBlYXQoc2l6ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google-cloud/precise-date/build/src/index.js\n");

/***/ })

};
;