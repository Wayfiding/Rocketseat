"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/eventsource";
exports.ids = ["vendor-chunks/eventsource"];
exports.modules = {

/***/ "(rsc)/./node_modules/eventsource/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/eventsource/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorEvent: () => (/* binding */ ErrorEvent),\n/* harmony export */   EventSource: () => (/* binding */ EventSource)\n/* harmony export */ });\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\n\nclass ErrorEvent extends Event {\n  /**\n   * Constructs a new `ErrorEvent` instance. This is typically not called directly,\n   * but rather emitted by the `EventSource` object when an error occurs.\n   *\n   * @param type - The type of the event (should be \"error\")\n   * @param errorEventInitDict - Optional properties to include in the error event\n   */\n  constructor(type, errorEventInitDict) {\n    var _a, _b;\n    super(type), this.code = (_a = errorEventInitDict == null ? void 0 : errorEventInitDict.code) != null ? _a : void 0, this.message = (_b = errorEventInitDict == null ? void 0 : errorEventInitDict.message) != null ? _b : void 0;\n  }\n  /**\n   * Node.js \"hides\" the `message` and `code` properties of the `ErrorEvent` instance,\n   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,\n   * we explicitly include the properties in the `inspect` method.\n   *\n   * This is automatically called by Node.js when you `console.log` an instance of this class.\n   *\n   * @param _depth - The current depth\n   * @param options - The options passed to `util.inspect`\n   * @param inspect - The inspect function to use (prevents having to import it from `util`)\n   * @returns A string representation of the error\n   */\n  [Symbol.for(\"nodejs.util.inspect.custom\")](_depth, options, inspect) {\n    return inspect(inspectableError(this), options);\n  }\n  /**\n   * Deno \"hides\" the `message` and `code` properties of the `ErrorEvent` instance,\n   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,\n   * we explicitly include the properties in the `inspect` method.\n   *\n   * This is automatically called by Deno when you `console.log` an instance of this class.\n   *\n   * @param inspect - The inspect function to use (prevents having to import it from `util`)\n   * @param options - The options passed to `Deno.inspect`\n   * @returns A string representation of the error\n   */\n  [Symbol.for(\"Deno.customInspect\")](inspect, options) {\n    return inspect(inspectableError(this), options);\n  }\n}\nfunction syntaxError(message) {\n  const DomException = globalThis.DOMException;\n  return typeof DomException == \"function\" ? new DomException(message, \"SyntaxError\") : new SyntaxError(message);\n}\nfunction flattenError(err) {\n  return err instanceof Error ? \"errors\" in err && Array.isArray(err.errors) ? err.errors.map(flattenError).join(\", \") : \"cause\" in err && err.cause instanceof Error ? `${err}: ${flattenError(err.cause)}` : err.message : `${err}`;\n}\nfunction inspectableError(err) {\n  return {\n    type: err.type,\n    message: err.message,\n    code: err.code,\n    defaultPrevented: err.defaultPrevented,\n    cancelable: err.cancelable,\n    timeStamp: err.timeStamp\n  };\n}\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n}, __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg), __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj)), __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value), __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), member.set(obj, value), value), __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method), _readyState, _url, _redirectUrl, _withCredentials, _fetch, _reconnectInterval, _reconnectTimer, _lastEventId, _controller, _parser, _onError, _onMessage, _onOpen, _EventSource_instances, connect_fn, _onFetchResponse, _onFetchError, getRequestOptions_fn, _onEvent, _onRetryChange, failConnection_fn, scheduleReconnect_fn, _reconnect;\nclass EventSource extends EventTarget {\n  constructor(url, eventSourceInitDict) {\n    var _a, _b;\n    super(), __privateAdd(this, _EventSource_instances), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, __privateAdd(this, _readyState), __privateAdd(this, _url), __privateAdd(this, _redirectUrl), __privateAdd(this, _withCredentials), __privateAdd(this, _fetch), __privateAdd(this, _reconnectInterval), __privateAdd(this, _reconnectTimer), __privateAdd(this, _lastEventId, null), __privateAdd(this, _controller), __privateAdd(this, _parser), __privateAdd(this, _onError, null), __privateAdd(this, _onMessage, null), __privateAdd(this, _onOpen, null), __privateAdd(this, _onFetchResponse, async (response) => {\n      var _a2;\n      __privateGet(this, _parser).reset();\n      const { body, redirected, status, headers } = response;\n      if (status === 204) {\n        __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, \"Server sent HTTP 204, not reconnecting\", 204), this.close();\n        return;\n      }\n      if (redirected ? __privateSet(this, _redirectUrl, new URL(response.url)) : __privateSet(this, _redirectUrl, void 0), status !== 200) {\n        __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, `Non-200 status code (${status})`, status);\n        return;\n      }\n      if (!(headers.get(\"content-type\") || \"\").startsWith(\"text/event-stream\")) {\n        __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, 'Invalid content type, expected \"text/event-stream\"', status);\n        return;\n      }\n      if (__privateGet(this, _readyState) === this.CLOSED)\n        return;\n      __privateSet(this, _readyState, this.OPEN);\n      const openEvent = new Event(\"open\");\n      if ((_a2 = __privateGet(this, _onOpen)) == null || _a2.call(this, openEvent), this.dispatchEvent(openEvent), typeof body != \"object\" || !body || !(\"getReader\" in body)) {\n        __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, \"Invalid response body, expected a web ReadableStream\", status), this.close();\n        return;\n      }\n      const decoder = new TextDecoder(), reader = body.getReader();\n      let open = !0;\n      do {\n        const { done, value } = await reader.read();\n        value && __privateGet(this, _parser).feed(decoder.decode(value, { stream: !done })), done && (open = !1, __privateGet(this, _parser).reset(), __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this));\n      } while (open);\n    }), __privateAdd(this, _onFetchError, (err) => {\n      __privateSet(this, _controller, void 0), !(err.name === \"AbortError\" || err.type === \"aborted\") && __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this, flattenError(err));\n    }), __privateAdd(this, _onEvent, (event) => {\n      typeof event.id == \"string\" && __privateSet(this, _lastEventId, event.id);\n      const messageEvent = new MessageEvent(event.event || \"message\", {\n        data: event.data,\n        origin: __privateGet(this, _redirectUrl) ? __privateGet(this, _redirectUrl).origin : __privateGet(this, _url).origin,\n        lastEventId: event.id || \"\"\n      });\n      __privateGet(this, _onMessage) && (!event.event || event.event === \"message\") && __privateGet(this, _onMessage).call(this, messageEvent), this.dispatchEvent(messageEvent);\n    }), __privateAdd(this, _onRetryChange, (value) => {\n      __privateSet(this, _reconnectInterval, value);\n    }), __privateAdd(this, _reconnect, () => {\n      __privateSet(this, _reconnectTimer, void 0), __privateGet(this, _readyState) === this.CONNECTING && __privateMethod(this, _EventSource_instances, connect_fn).call(this);\n    });\n    try {\n      if (url instanceof URL)\n        __privateSet(this, _url, url);\n      else if (typeof url == \"string\")\n        __privateSet(this, _url, new URL(url, getBaseURL()));\n      else\n        throw new Error(\"Invalid URL\");\n    } catch {\n      throw syntaxError(\"An invalid or illegal string was specified\");\n    }\n    __privateSet(this, _parser, (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_0__.createParser)({\n      onEvent: __privateGet(this, _onEvent),\n      onRetry: __privateGet(this, _onRetryChange)\n    })), __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _reconnectInterval, 3e3), __privateSet(this, _fetch, (_a = eventSourceInitDict == null ? void 0 : eventSourceInitDict.fetch) != null ? _a : globalThis.fetch), __privateSet(this, _withCredentials, (_b = eventSourceInitDict == null ? void 0 : eventSourceInitDict.withCredentials) != null ? _b : !1), __privateMethod(this, _EventSource_instances, connect_fn).call(this);\n  }\n  /**\n   * Returns the state of this EventSource object's connection. It can have the values described below.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)\n   *\n   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,\n   * defined in the TypeScript `dom` library.\n   *\n   * @public\n   */\n  get readyState() {\n    return __privateGet(this, _readyState);\n  }\n  /**\n   * Returns the URL providing the event stream.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)\n   *\n   * @public\n   */\n  get url() {\n    return __privateGet(this, _url).href;\n  }\n  /**\n   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to \"include\", and false otherwise.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)\n   */\n  get withCredentials() {\n    return __privateGet(this, _withCredentials);\n  }\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */\n  get onerror() {\n    return __privateGet(this, _onError);\n  }\n  set onerror(value) {\n    __privateSet(this, _onError, value);\n  }\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */\n  get onmessage() {\n    return __privateGet(this, _onMessage);\n  }\n  set onmessage(value) {\n    __privateSet(this, _onMessage, value);\n  }\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */\n  get onopen() {\n    return __privateGet(this, _onOpen);\n  }\n  set onopen(value) {\n    __privateSet(this, _onOpen, value);\n  }\n  addEventListener(type, listener, options) {\n    const listen = listener;\n    super.addEventListener(type, listen, options);\n  }\n  removeEventListener(type, listener, options) {\n    const listen = listener;\n    super.removeEventListener(type, listen, options);\n  }\n  /**\n   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)\n   *\n   * @public\n   */\n  close() {\n    __privateGet(this, _reconnectTimer) && clearTimeout(__privateGet(this, _reconnectTimer)), __privateGet(this, _readyState) !== this.CLOSED && (__privateGet(this, _controller) && __privateGet(this, _controller).abort(), __privateSet(this, _readyState, this.CLOSED), __privateSet(this, _controller, void 0));\n  }\n}\n_readyState = /* @__PURE__ */ new WeakMap(), _url = /* @__PURE__ */ new WeakMap(), _redirectUrl = /* @__PURE__ */ new WeakMap(), _withCredentials = /* @__PURE__ */ new WeakMap(), _fetch = /* @__PURE__ */ new WeakMap(), _reconnectInterval = /* @__PURE__ */ new WeakMap(), _reconnectTimer = /* @__PURE__ */ new WeakMap(), _lastEventId = /* @__PURE__ */ new WeakMap(), _controller = /* @__PURE__ */ new WeakMap(), _parser = /* @__PURE__ */ new WeakMap(), _onError = /* @__PURE__ */ new WeakMap(), _onMessage = /* @__PURE__ */ new WeakMap(), _onOpen = /* @__PURE__ */ new WeakMap(), _EventSource_instances = /* @__PURE__ */ new WeakSet(), /**\n* Connect to the given URL and start receiving events\n*\n* @internal\n*/\nconnect_fn = function() {\n  __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _controller, new AbortController()), __privateGet(this, _fetch)(__privateGet(this, _url), __privateMethod(this, _EventSource_instances, getRequestOptions_fn).call(this)).then(__privateGet(this, _onFetchResponse)).catch(__privateGet(this, _onFetchError));\n}, _onFetchResponse = /* @__PURE__ */ new WeakMap(), _onFetchError = /* @__PURE__ */ new WeakMap(), /**\n* Get request options for the `fetch()` request\n*\n* @returns The request options\n* @internal\n*/\ngetRequestOptions_fn = function() {\n  var _a;\n  const init = {\n    // [spec] Let `corsAttributeState` be `Anonymous`…\n    // [spec] …will have their mode set to \"cors\"…\n    mode: \"cors\",\n    redirect: \"follow\",\n    headers: { Accept: \"text/event-stream\", ...__privateGet(this, _lastEventId) ? { \"Last-Event-ID\": __privateGet(this, _lastEventId) } : void 0 },\n    cache: \"no-store\",\n    signal: (_a = __privateGet(this, _controller)) == null ? void 0 : _a.signal\n  };\n  return \"window\" in globalThis && (init.credentials = this.withCredentials ? \"include\" : \"same-origin\"), init;\n}, _onEvent = /* @__PURE__ */ new WeakMap(), _onRetryChange = /* @__PURE__ */ new WeakMap(), /**\n* Handles the process referred to in the EventSource specification as \"failing a connection\".\n*\n* @param error - The error causing the connection to fail\n* @param code - The HTTP status code, if available\n* @internal\n*/\nfailConnection_fn = function(message, code) {\n  var _a;\n  __privateGet(this, _readyState) !== this.CLOSED && __privateSet(this, _readyState, this.CLOSED);\n  const errorEvent = new ErrorEvent(\"error\", { code, message });\n  (_a = __privateGet(this, _onError)) == null || _a.call(this, errorEvent), this.dispatchEvent(errorEvent);\n}, /**\n* Schedules a reconnection attempt against the EventSource endpoint.\n*\n* @param message - The error causing the connection to fail\n* @param code - The HTTP status code, if available\n* @internal\n*/\nscheduleReconnect_fn = function(message, code) {\n  var _a;\n  if (__privateGet(this, _readyState) === this.CLOSED)\n    return;\n  __privateSet(this, _readyState, this.CONNECTING);\n  const errorEvent = new ErrorEvent(\"error\", { code, message });\n  (_a = __privateGet(this, _onError)) == null || _a.call(this, errorEvent), this.dispatchEvent(errorEvent), __privateSet(this, _reconnectTimer, setTimeout(__privateGet(this, _reconnect), __privateGet(this, _reconnectInterval)));\n}, _reconnect = /* @__PURE__ */ new WeakMap(), /**\n* ReadyState representing an EventSource currently trying to connect\n*\n* @public\n*/\nEventSource.CONNECTING = 0, /**\n* ReadyState representing an EventSource connection that is open (eg connected)\n*\n* @public\n*/\nEventSource.OPEN = 1, /**\n* ReadyState representing an EventSource connection that is closed (eg disconnected)\n*\n* @public\n*/\nEventSource.CLOSED = 2;\nfunction getBaseURL() {\n  const doc = \"document\" in globalThis ? globalThis.document : void 0;\n  return doc && typeof doc == \"object\" && \"baseURI\" in doc && typeof doc.baseURI == \"string\" ? doc.baseURI : void 0;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXZlbnRzb3VyY2UvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJLQUEySyxJQUFJLElBQUksd0JBQXdCLHFCQUFxQixJQUFJO0FBQ3BPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0NBQW9DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsT0FBTztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsMEVBQTBFLGVBQWU7QUFDekYsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0VBQVk7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFFQUFxRSxvREFBb0QsVUFBVTtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGVBQWU7QUFDOUQ7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyIvaG9tZS9hbGJlcnRvL0RvY3VtZW50b3MvRGVzZW52b2x2aW1lbnRvIFdlYi9Sb2NrZXRzZWF0L1RyaWdnZXJEZXYvbm9kZV9tb2R1bGVzL2V2ZW50c291cmNlL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlUGFyc2VyIH0gZnJvbSBcImV2ZW50c291cmNlLXBhcnNlclwiO1xuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYEVycm9yRXZlbnRgIGluc3RhbmNlLiBUaGlzIGlzIHR5cGljYWxseSBub3QgY2FsbGVkIGRpcmVjdGx5LFxuICAgKiBidXQgcmF0aGVyIGVtaXR0ZWQgYnkgdGhlIGBFdmVudFNvdXJjZWAgb2JqZWN0IHdoZW4gYW4gZXJyb3Igb2NjdXJzLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCAoc2hvdWxkIGJlIFwiZXJyb3JcIilcbiAgICogQHBhcmFtIGVycm9yRXZlbnRJbml0RGljdCAtIE9wdGlvbmFsIHByb3BlcnRpZXMgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IgZXZlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIGVycm9yRXZlbnRJbml0RGljdCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgc3VwZXIodHlwZSksIHRoaXMuY29kZSA9IChfYSA9IGVycm9yRXZlbnRJbml0RGljdCA9PSBudWxsID8gdm9pZCAwIDogZXJyb3JFdmVudEluaXREaWN0LmNvZGUpICE9IG51bGwgPyBfYSA6IHZvaWQgMCwgdGhpcy5tZXNzYWdlID0gKF9iID0gZXJyb3JFdmVudEluaXREaWN0ID09IG51bGwgPyB2b2lkIDAgOiBlcnJvckV2ZW50SW5pdERpY3QubWVzc2FnZSkgIT0gbnVsbCA/IF9iIDogdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBOb2RlLmpzIFwiaGlkZXNcIiB0aGUgYG1lc3NhZ2VgIGFuZCBgY29kZWAgcHJvcGVydGllcyBvZiB0aGUgYEVycm9yRXZlbnRgIGluc3RhbmNlLFxuICAgKiB3aGVuIGl0IGlzIGBjb25zb2xlLmxvZ2AnZWQuIFRoaXMgbWFrZXMgaXQgaGFyZGVyIHRvIGRlYnVnIGVycm9ycy4gVG8gZWFzZSBkZWJ1Z2dpbmcsXG4gICAqIHdlIGV4cGxpY2l0bHkgaW5jbHVkZSB0aGUgcHJvcGVydGllcyBpbiB0aGUgYGluc3BlY3RgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBOb2RlLmpzIHdoZW4geW91IGBjb25zb2xlLmxvZ2AgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIF9kZXB0aCAtIFRoZSBjdXJyZW50IGRlcHRoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIGB1dGlsLmluc3BlY3RgXG4gICAqIEBwYXJhbSBpbnNwZWN0IC0gVGhlIGluc3BlY3QgZnVuY3Rpb24gdG8gdXNlIChwcmV2ZW50cyBoYXZpbmcgdG8gaW1wb3J0IGl0IGZyb20gYHV0aWxgKVxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3JcbiAgICovXG4gIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKF9kZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgIHJldHVybiBpbnNwZWN0KGluc3BlY3RhYmxlRXJyb3IodGhpcyksIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBEZW5vIFwiaGlkZXNcIiB0aGUgYG1lc3NhZ2VgIGFuZCBgY29kZWAgcHJvcGVydGllcyBvZiB0aGUgYEVycm9yRXZlbnRgIGluc3RhbmNlLFxuICAgKiB3aGVuIGl0IGlzIGBjb25zb2xlLmxvZ2AnZWQuIFRoaXMgbWFrZXMgaXQgaGFyZGVyIHRvIGRlYnVnIGVycm9ycy4gVG8gZWFzZSBkZWJ1Z2dpbmcsXG4gICAqIHdlIGV4cGxpY2l0bHkgaW5jbHVkZSB0aGUgcHJvcGVydGllcyBpbiB0aGUgYGluc3BlY3RgIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBEZW5vIHdoZW4geW91IGBjb25zb2xlLmxvZ2AgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIGluc3BlY3QgLSBUaGUgaW5zcGVjdCBmdW5jdGlvbiB0byB1c2UgKHByZXZlbnRzIGhhdmluZyB0byBpbXBvcnQgaXQgZnJvbSBgdXRpbGApXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIGBEZW5vLmluc3BlY3RgXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvclxuICAgKi9cbiAgW1N5bWJvbC5mb3IoXCJEZW5vLmN1c3RvbUluc3BlY3RcIildKGluc3BlY3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaW5zcGVjdChpbnNwZWN0YWJsZUVycm9yKHRoaXMpLCBvcHRpb25zKTtcbiAgfVxufVxuZnVuY3Rpb24gc3ludGF4RXJyb3IobWVzc2FnZSkge1xuICBjb25zdCBEb21FeGNlcHRpb24gPSBnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbjtcbiAgcmV0dXJuIHR5cGVvZiBEb21FeGNlcHRpb24gPT0gXCJmdW5jdGlvblwiID8gbmV3IERvbUV4Y2VwdGlvbihtZXNzYWdlLCBcIlN5bnRheEVycm9yXCIpIDogbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gZmxhdHRlbkVycm9yKGVycikge1xuICByZXR1cm4gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBcImVycm9yc1wiIGluIGVyciAmJiBBcnJheS5pc0FycmF5KGVyci5lcnJvcnMpID8gZXJyLmVycm9ycy5tYXAoZmxhdHRlbkVycm9yKS5qb2luKFwiLCBcIikgOiBcImNhdXNlXCIgaW4gZXJyICYmIGVyci5jYXVzZSBpbnN0YW5jZW9mIEVycm9yID8gYCR7ZXJyfTogJHtmbGF0dGVuRXJyb3IoZXJyLmNhdXNlKX1gIDogZXJyLm1lc3NhZ2UgOiBgJHtlcnJ9YDtcbn1cbmZ1bmN0aW9uIGluc3BlY3RhYmxlRXJyb3IoZXJyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXJyLnR5cGUsXG4gICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgY29kZTogZXJyLmNvZGUsXG4gICAgZGVmYXVsdFByZXZlbnRlZDogZXJyLmRlZmF1bHRQcmV2ZW50ZWQsXG4gICAgY2FuY2VsYWJsZTogZXJyLmNhbmNlbGFibGUsXG4gICAgdGltZVN0YW1wOiBlcnIudGltZVN0YW1wXG4gIH07XG59XG52YXIgX190eXBlRXJyb3IgPSAobXNnKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihtc2cpO1xufSwgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiBtZW1iZXIuaGFzKG9iaikgfHwgX190eXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpLCBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaikpLCBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiBtZW1iZXIuaGFzKG9iaikgPyBfX3R5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKSwgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLCBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpLCB2YWx1ZSksIF9fcHJpdmF0ZU1ldGhvZCA9IChvYmosIG1lbWJlciwgbWV0aG9kKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJhY2Nlc3MgcHJpdmF0ZSBtZXRob2RcIiksIG1ldGhvZCksIF9yZWFkeVN0YXRlLCBfdXJsLCBfcmVkaXJlY3RVcmwsIF93aXRoQ3JlZGVudGlhbHMsIF9mZXRjaCwgX3JlY29ubmVjdEludGVydmFsLCBfcmVjb25uZWN0VGltZXIsIF9sYXN0RXZlbnRJZCwgX2NvbnRyb2xsZXIsIF9wYXJzZXIsIF9vbkVycm9yLCBfb25NZXNzYWdlLCBfb25PcGVuLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzLCBjb25uZWN0X2ZuLCBfb25GZXRjaFJlc3BvbnNlLCBfb25GZXRjaEVycm9yLCBnZXRSZXF1ZXN0T3B0aW9uc19mbiwgX29uRXZlbnQsIF9vblJldHJ5Q2hhbmdlLCBmYWlsQ29ubmVjdGlvbl9mbiwgc2NoZWR1bGVSZWNvbm5lY3RfZm4sIF9yZWNvbm5lY3Q7XG5jbGFzcyBFdmVudFNvdXJjZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgY29uc3RydWN0b3IodXJsLCBldmVudFNvdXJjZUluaXREaWN0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBzdXBlcigpLCBfX3ByaXZhdGVBZGQodGhpcywgX0V2ZW50U291cmNlX2luc3RhbmNlcyksIHRoaXMuQ09OTkVDVElORyA9IDAsIHRoaXMuT1BFTiA9IDEsIHRoaXMuQ0xPU0VEID0gMiwgX19wcml2YXRlQWRkKHRoaXMsIF9yZWFkeVN0YXRlKSwgX19wcml2YXRlQWRkKHRoaXMsIF91cmwpLCBfX3ByaXZhdGVBZGQodGhpcywgX3JlZGlyZWN0VXJsKSwgX19wcml2YXRlQWRkKHRoaXMsIF93aXRoQ3JlZGVudGlhbHMpLCBfX3ByaXZhdGVBZGQodGhpcywgX2ZldGNoKSwgX19wcml2YXRlQWRkKHRoaXMsIF9yZWNvbm5lY3RJbnRlcnZhbCksIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcmVjb25uZWN0VGltZXIpLCBfX3ByaXZhdGVBZGQodGhpcywgX2xhc3RFdmVudElkLCBudWxsKSwgX19wcml2YXRlQWRkKHRoaXMsIF9jb250cm9sbGVyKSwgX19wcml2YXRlQWRkKHRoaXMsIF9wYXJzZXIpLCBfX3ByaXZhdGVBZGQodGhpcywgX29uRXJyb3IsIG51bGwpLCBfX3ByaXZhdGVBZGQodGhpcywgX29uTWVzc2FnZSwgbnVsbCksIF9fcHJpdmF0ZUFkZCh0aGlzLCBfb25PcGVuLCBudWxsKSwgX19wcml2YXRlQWRkKHRoaXMsIF9vbkZldGNoUmVzcG9uc2UsIGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcGFyc2VyKS5yZXNldCgpO1xuICAgICAgY29uc3QgeyBib2R5LCByZWRpcmVjdGVkLCBzdGF0dXMsIGhlYWRlcnMgfSA9IHJlc3BvbnNlO1xuICAgICAgaWYgKHN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzLCBmYWlsQ29ubmVjdGlvbl9mbikuY2FsbCh0aGlzLCBcIlNlcnZlciBzZW50IEhUVFAgMjA0LCBub3QgcmVjb25uZWN0aW5nXCIsIDIwNCksIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlZGlyZWN0ZWQgPyBfX3ByaXZhdGVTZXQodGhpcywgX3JlZGlyZWN0VXJsLCBuZXcgVVJMKHJlc3BvbnNlLnVybCkpIDogX19wcml2YXRlU2V0KHRoaXMsIF9yZWRpcmVjdFVybCwgdm9pZCAwKSwgc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9FdmVudFNvdXJjZV9pbnN0YW5jZXMsIGZhaWxDb25uZWN0aW9uX2ZuKS5jYWxsKHRoaXMsIGBOb24tMjAwIHN0YXR1cyBjb2RlICgke3N0YXR1c30pYCwgc3RhdHVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCEoaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIikuc3RhcnRzV2l0aChcInRleHQvZXZlbnQtc3RyZWFtXCIpKSB7XG4gICAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzLCBmYWlsQ29ubmVjdGlvbl9mbikuY2FsbCh0aGlzLCAnSW52YWxpZCBjb250ZW50IHR5cGUsIGV4cGVjdGVkIFwidGV4dC9ldmVudC1zdHJlYW1cIicsIHN0YXR1cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX3JlYWR5U3RhdGUpID09PSB0aGlzLkNMT1NFRClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9yZWFkeVN0YXRlLCB0aGlzLk9QRU4pO1xuICAgICAgY29uc3Qgb3BlbkV2ZW50ID0gbmV3IEV2ZW50KFwib3BlblwiKTtcbiAgICAgIGlmICgoX2EyID0gX19wcml2YXRlR2V0KHRoaXMsIF9vbk9wZW4pKSA9PSBudWxsIHx8IF9hMi5jYWxsKHRoaXMsIG9wZW5FdmVudCksIHRoaXMuZGlzcGF0Y2hFdmVudChvcGVuRXZlbnQpLCB0eXBlb2YgYm9keSAhPSBcIm9iamVjdFwiIHx8ICFib2R5IHx8ICEoXCJnZXRSZWFkZXJcIiBpbiBib2R5KSkge1xuICAgICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX0V2ZW50U291cmNlX2luc3RhbmNlcywgZmFpbENvbm5lY3Rpb25fZm4pLmNhbGwodGhpcywgXCJJbnZhbGlkIHJlc3BvbnNlIGJvZHksIGV4cGVjdGVkIGEgd2ViIFJlYWRhYmxlU3RyZWFtXCIsIHN0YXR1cyksIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpLCByZWFkZXIgPSBib2R5LmdldFJlYWRlcigpO1xuICAgICAgbGV0IG9wZW4gPSAhMDtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgdmFsdWUgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9wYXJzZXIpLmZlZWQoZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiAhZG9uZSB9KSksIGRvbmUgJiYgKG9wZW4gPSAhMSwgX19wcml2YXRlR2V0KHRoaXMsIF9wYXJzZXIpLnJlc2V0KCksIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRXZlbnRTb3VyY2VfaW5zdGFuY2VzLCBzY2hlZHVsZVJlY29ubmVjdF9mbikuY2FsbCh0aGlzKSk7XG4gICAgICB9IHdoaWxlIChvcGVuKTtcbiAgICB9KSwgX19wcml2YXRlQWRkKHRoaXMsIF9vbkZldGNoRXJyb3IsIChlcnIpID0+IHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfY29udHJvbGxlciwgdm9pZCAwKSwgIShlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgfHwgZXJyLnR5cGUgPT09IFwiYWJvcnRlZFwiKSAmJiBfX3ByaXZhdGVNZXRob2QodGhpcywgX0V2ZW50U291cmNlX2luc3RhbmNlcywgc2NoZWR1bGVSZWNvbm5lY3RfZm4pLmNhbGwodGhpcywgZmxhdHRlbkVycm9yKGVycikpO1xuICAgIH0pLCBfX3ByaXZhdGVBZGQodGhpcywgX29uRXZlbnQsIChldmVudCkgPT4ge1xuICAgICAgdHlwZW9mIGV2ZW50LmlkID09IFwic3RyaW5nXCIgJiYgX19wcml2YXRlU2V0KHRoaXMsIF9sYXN0RXZlbnRJZCwgZXZlbnQuaWQpO1xuICAgICAgY29uc3QgbWVzc2FnZUV2ZW50ID0gbmV3IE1lc3NhZ2VFdmVudChldmVudC5ldmVudCB8fCBcIm1lc3NhZ2VcIiwge1xuICAgICAgICBkYXRhOiBldmVudC5kYXRhLFxuICAgICAgICBvcmlnaW46IF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVkaXJlY3RVcmwpID8gX19wcml2YXRlR2V0KHRoaXMsIF9yZWRpcmVjdFVybCkub3JpZ2luIDogX19wcml2YXRlR2V0KHRoaXMsIF91cmwpLm9yaWdpbixcbiAgICAgICAgbGFzdEV2ZW50SWQ6IGV2ZW50LmlkIHx8IFwiXCJcbiAgICAgIH0pO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9vbk1lc3NhZ2UpICYmICghZXZlbnQuZXZlbnQgfHwgZXZlbnQuZXZlbnQgPT09IFwibWVzc2FnZVwiKSAmJiBfX3ByaXZhdGVHZXQodGhpcywgX29uTWVzc2FnZSkuY2FsbCh0aGlzLCBtZXNzYWdlRXZlbnQpLCB0aGlzLmRpc3BhdGNoRXZlbnQobWVzc2FnZUV2ZW50KTtcbiAgICB9KSwgX19wcml2YXRlQWRkKHRoaXMsIF9vblJldHJ5Q2hhbmdlLCAodmFsdWUpID0+IHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVjb25uZWN0SW50ZXJ2YWwsIHZhbHVlKTtcbiAgICB9KSwgX19wcml2YXRlQWRkKHRoaXMsIF9yZWNvbm5lY3QsICgpID0+IHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVjb25uZWN0VGltZXIsIHZvaWQgMCksIF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVhZHlTdGF0ZSkgPT09IHRoaXMuQ09OTkVDVElORyAmJiBfX3ByaXZhdGVNZXRob2QodGhpcywgX0V2ZW50U291cmNlX2luc3RhbmNlcywgY29ubmVjdF9mbikuY2FsbCh0aGlzKTtcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgaWYgKHVybCBpbnN0YW5jZW9mIFVSTClcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF91cmwsIHVybCk7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgdXJsID09IFwic3RyaW5nXCIpXG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdXJsLCBuZXcgVVJMKHVybCwgZ2V0QmFzZVVSTCgpKSk7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgVVJMXCIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcGFyc2VyLCBjcmVhdGVQYXJzZXIoe1xuICAgICAgb25FdmVudDogX19wcml2YXRlR2V0KHRoaXMsIF9vbkV2ZW50KSxcbiAgICAgIG9uUmV0cnk6IF9fcHJpdmF0ZUdldCh0aGlzLCBfb25SZXRyeUNoYW5nZSlcbiAgICB9KSksIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVhZHlTdGF0ZSwgdGhpcy5DT05ORUNUSU5HKSwgX19wcml2YXRlU2V0KHRoaXMsIF9yZWNvbm5lY3RJbnRlcnZhbCwgM2UzKSwgX19wcml2YXRlU2V0KHRoaXMsIF9mZXRjaCwgKF9hID0gZXZlbnRTb3VyY2VJbml0RGljdCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnRTb3VyY2VJbml0RGljdC5mZXRjaCkgIT0gbnVsbCA/IF9hIDogZ2xvYmFsVGhpcy5mZXRjaCksIF9fcHJpdmF0ZVNldCh0aGlzLCBfd2l0aENyZWRlbnRpYWxzLCAoX2IgPSBldmVudFNvdXJjZUluaXREaWN0ID09IG51bGwgPyB2b2lkIDAgOiBldmVudFNvdXJjZUluaXREaWN0LndpdGhDcmVkZW50aWFscykgIT0gbnVsbCA/IF9iIDogITEpLCBfX3ByaXZhdGVNZXRob2QodGhpcywgX0V2ZW50U291cmNlX2luc3RhbmNlcywgY29ubmVjdF9mbikuY2FsbCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdGUgb2YgdGhpcyBFdmVudFNvdXJjZSBvYmplY3QncyBjb25uZWN0aW9uLiBJdCBjYW4gaGF2ZSB0aGUgdmFsdWVzIGRlc2NyaWJlZCBiZWxvdy5cbiAgICpcbiAgICogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9yZWFkeVN0YXRlKVxuICAgKlxuICAgKiBOb3RlOiB0eXBlZCBhcyBgbnVtYmVyYCBpbnN0ZWFkIG9mIGAwIHwgMSB8IDJgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGBFdmVudFNvdXJjZWAgaW50ZXJmYWNlLFxuICAgKiBkZWZpbmVkIGluIHRoZSBUeXBlU2NyaXB0IGBkb21gIGxpYnJhcnkuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldCByZWFkeVN0YXRlKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3JlYWR5U3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBVUkwgcHJvdmlkaW5nIHRoZSBldmVudCBzdHJlYW0uXG4gICAqXG4gICAqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnRTb3VyY2UvdXJsKVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3VybCkuaHJlZjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjcmVkZW50aWFscyBtb2RlIGZvciBjb25uZWN0aW9uIHJlcXVlc3RzIHRvIHRoZSBVUkwgcHJvdmlkaW5nIHRoZSBldmVudCBzdHJlYW0gaXMgc2V0IHRvIFwiaW5jbHVkZVwiLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50U291cmNlL3dpdGhDcmVkZW50aWFscylcbiAgICovXG4gIGdldCB3aXRoQ3JlZGVudGlhbHMoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfd2l0aENyZWRlbnRpYWxzKTtcbiAgfVxuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9lcnJvcl9ldmVudCkgKi9cbiAgZ2V0IG9uZXJyb3IoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25FcnJvcik7XG4gIH1cbiAgc2V0IG9uZXJyb3IodmFsdWUpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX29uRXJyb3IsIHZhbHVlKTtcbiAgfVxuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9tZXNzYWdlX2V2ZW50KSAqL1xuICBnZXQgb25tZXNzYWdlKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX29uTWVzc2FnZSk7XG4gIH1cbiAgc2V0IG9ubWVzc2FnZSh2YWx1ZSkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfb25NZXNzYWdlLCB2YWx1ZSk7XG4gIH1cbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnRTb3VyY2Uvb3Blbl9ldmVudCkgKi9cbiAgZ2V0IG9ub3BlbigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9vbk9wZW4pO1xuICB9XG4gIHNldCBvbm9wZW4odmFsdWUpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX29uT3BlbiwgdmFsdWUpO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsaXN0ZW4gPSBsaXN0ZW5lcjtcbiAgICBzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3Rlbiwgb3B0aW9ucyk7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxpc3RlbiA9IGxpc3RlbmVyO1xuICAgIHN1cGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQWJvcnRzIGFueSBpbnN0YW5jZXMgb2YgdGhlIGZldGNoIGFsZ29yaXRobSBzdGFydGVkIGZvciB0aGlzIEV2ZW50U291cmNlIG9iamVjdCwgYW5kIHNldHMgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvIENMT1NFRC5cbiAgICpcbiAgICogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudFNvdXJjZS9jbG9zZSlcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9yZWNvbm5lY3RUaW1lcikgJiYgY2xlYXJUaW1lb3V0KF9fcHJpdmF0ZUdldCh0aGlzLCBfcmVjb25uZWN0VGltZXIpKSwgX19wcml2YXRlR2V0KHRoaXMsIF9yZWFkeVN0YXRlKSAhPT0gdGhpcy5DTE9TRUQgJiYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfY29udHJvbGxlcikgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9jb250cm9sbGVyKS5hYm9ydCgpLCBfX3ByaXZhdGVTZXQodGhpcywgX3JlYWR5U3RhdGUsIHRoaXMuQ0xPU0VEKSwgX19wcml2YXRlU2V0KHRoaXMsIF9jb250cm9sbGVyLCB2b2lkIDApKTtcbiAgfVxufVxuX3JlYWR5U3RhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX3VybCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfcmVkaXJlY3RVcmwgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX3dpdGhDcmVkZW50aWFscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfZmV0Y2ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX3JlY29ubmVjdEludGVydmFsID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9yZWNvbm5lY3RUaW1lciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfbGFzdEV2ZW50SWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX2NvbnRyb2xsZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX3BhcnNlciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfb25FcnJvciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfb25NZXNzYWdlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9vbk9wZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX0V2ZW50U291cmNlX2luc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpLCAvKipcbiogQ29ubmVjdCB0byB0aGUgZ2l2ZW4gVVJMIGFuZCBzdGFydCByZWNlaXZpbmcgZXZlbnRzXG4qXG4qIEBpbnRlcm5hbFxuKi9cbmNvbm5lY3RfZm4gPSBmdW5jdGlvbigpIHtcbiAgX19wcml2YXRlU2V0KHRoaXMsIF9yZWFkeVN0YXRlLCB0aGlzLkNPTk5FQ1RJTkcpLCBfX3ByaXZhdGVTZXQodGhpcywgX2NvbnRyb2xsZXIsIG5ldyBBYm9ydENvbnRyb2xsZXIoKSksIF9fcHJpdmF0ZUdldCh0aGlzLCBfZmV0Y2gpKF9fcHJpdmF0ZUdldCh0aGlzLCBfdXJsKSwgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9FdmVudFNvdXJjZV9pbnN0YW5jZXMsIGdldFJlcXVlc3RPcHRpb25zX2ZuKS5jYWxsKHRoaXMpKS50aGVuKF9fcHJpdmF0ZUdldCh0aGlzLCBfb25GZXRjaFJlc3BvbnNlKSkuY2F0Y2goX19wcml2YXRlR2V0KHRoaXMsIF9vbkZldGNoRXJyb3IpKTtcbn0sIF9vbkZldGNoUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX29uRmV0Y2hFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCAvKipcbiogR2V0IHJlcXVlc3Qgb3B0aW9ucyBmb3IgdGhlIGBmZXRjaCgpYCByZXF1ZXN0XG4qXG4qIEByZXR1cm5zIFRoZSByZXF1ZXN0IG9wdGlvbnNcbiogQGludGVybmFsXG4qL1xuZ2V0UmVxdWVzdE9wdGlvbnNfZm4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBpbml0ID0ge1xuICAgIC8vIFtzcGVjXSBMZXQgYGNvcnNBdHRyaWJ1dGVTdGF0ZWAgYmUgYEFub255bW91c2DigKZcbiAgICAvLyBbc3BlY10g4oCmd2lsbCBoYXZlIHRoZWlyIG1vZGUgc2V0IHRvIFwiY29yc1wi4oCmXG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG4gICAgaGVhZGVyczogeyBBY2NlcHQ6IFwidGV4dC9ldmVudC1zdHJlYW1cIiwgLi4uX19wcml2YXRlR2V0KHRoaXMsIF9sYXN0RXZlbnRJZCkgPyB7IFwiTGFzdC1FdmVudC1JRFwiOiBfX3ByaXZhdGVHZXQodGhpcywgX2xhc3RFdmVudElkKSB9IDogdm9pZCAwIH0sXG4gICAgY2FjaGU6IFwibm8tc3RvcmVcIixcbiAgICBzaWduYWw6IChfYSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfY29udHJvbGxlcikpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zaWduYWxcbiAgfTtcbiAgcmV0dXJuIFwid2luZG93XCIgaW4gZ2xvYmFsVGhpcyAmJiAoaW5pdC5jcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcInNhbWUtb3JpZ2luXCIpLCBpbml0O1xufSwgX29uRXZlbnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX29uUmV0cnlDaGFuZ2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgLyoqXG4qIEhhbmRsZXMgdGhlIHByb2Nlc3MgcmVmZXJyZWQgdG8gaW4gdGhlIEV2ZW50U291cmNlIHNwZWNpZmljYXRpb24gYXMgXCJmYWlsaW5nIGEgY29ubmVjdGlvblwiLlxuKlxuKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgY2F1c2luZyB0aGUgY29ubmVjdGlvbiB0byBmYWlsXG4qIEBwYXJhbSBjb2RlIC0gVGhlIEhUVFAgc3RhdHVzIGNvZGUsIGlmIGF2YWlsYWJsZVxuKiBAaW50ZXJuYWxcbiovXG5mYWlsQ29ubmVjdGlvbl9mbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGNvZGUpIHtcbiAgdmFyIF9hO1xuICBfX3ByaXZhdGVHZXQodGhpcywgX3JlYWR5U3RhdGUpICE9PSB0aGlzLkNMT1NFRCAmJiBfX3ByaXZhdGVTZXQodGhpcywgX3JlYWR5U3RhdGUsIHRoaXMuQ0xPU0VEKTtcbiAgY29uc3QgZXJyb3JFdmVudCA9IG5ldyBFcnJvckV2ZW50KFwiZXJyb3JcIiwgeyBjb2RlLCBtZXNzYWdlIH0pO1xuICAoX2EgPSBfX3ByaXZhdGVHZXQodGhpcywgX29uRXJyb3IpKSA9PSBudWxsIHx8IF9hLmNhbGwodGhpcywgZXJyb3JFdmVudCksIHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvckV2ZW50KTtcbn0sIC8qKlxuKiBTY2hlZHVsZXMgYSByZWNvbm5lY3Rpb24gYXR0ZW1wdCBhZ2FpbnN0IHRoZSBFdmVudFNvdXJjZSBlbmRwb2ludC5cbipcbiogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgY2F1c2luZyB0aGUgY29ubmVjdGlvbiB0byBmYWlsXG4qIEBwYXJhbSBjb2RlIC0gVGhlIEhUVFAgc3RhdHVzIGNvZGUsIGlmIGF2YWlsYWJsZVxuKiBAaW50ZXJuYWxcbiovXG5zY2hlZHVsZVJlY29ubmVjdF9mbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGNvZGUpIHtcbiAgdmFyIF9hO1xuICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9yZWFkeVN0YXRlKSA9PT0gdGhpcy5DTE9TRUQpXG4gICAgcmV0dXJuO1xuICBfX3ByaXZhdGVTZXQodGhpcywgX3JlYWR5U3RhdGUsIHRoaXMuQ09OTkVDVElORyk7XG4gIGNvbnN0IGVycm9yRXZlbnQgPSBuZXcgRXJyb3JFdmVudChcImVycm9yXCIsIHsgY29kZSwgbWVzc2FnZSB9KTtcbiAgKF9hID0gX19wcml2YXRlR2V0KHRoaXMsIF9vbkVycm9yKSkgPT0gbnVsbCB8fCBfYS5jYWxsKHRoaXMsIGVycm9yRXZlbnQpLCB0aGlzLmRpc3BhdGNoRXZlbnQoZXJyb3JFdmVudCksIF9fcHJpdmF0ZVNldCh0aGlzLCBfcmVjb25uZWN0VGltZXIsIHNldFRpbWVvdXQoX19wcml2YXRlR2V0KHRoaXMsIF9yZWNvbm5lY3QpLCBfX3ByaXZhdGVHZXQodGhpcywgX3JlY29ubmVjdEludGVydmFsKSkpO1xufSwgX3JlY29ubmVjdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCAvKipcbiogUmVhZHlTdGF0ZSByZXByZXNlbnRpbmcgYW4gRXZlbnRTb3VyY2UgY3VycmVudGx5IHRyeWluZyB0byBjb25uZWN0XG4qXG4qIEBwdWJsaWNcbiovXG5FdmVudFNvdXJjZS5DT05ORUNUSU5HID0gMCwgLyoqXG4qIFJlYWR5U3RhdGUgcmVwcmVzZW50aW5nIGFuIEV2ZW50U291cmNlIGNvbm5lY3Rpb24gdGhhdCBpcyBvcGVuIChlZyBjb25uZWN0ZWQpXG4qXG4qIEBwdWJsaWNcbiovXG5FdmVudFNvdXJjZS5PUEVOID0gMSwgLyoqXG4qIFJlYWR5U3RhdGUgcmVwcmVzZW50aW5nIGFuIEV2ZW50U291cmNlIGNvbm5lY3Rpb24gdGhhdCBpcyBjbG9zZWQgKGVnIGRpc2Nvbm5lY3RlZClcbipcbiogQHB1YmxpY1xuKi9cbkV2ZW50U291cmNlLkNMT1NFRCA9IDI7XG5mdW5jdGlvbiBnZXRCYXNlVVJMKCkge1xuICBjb25zdCBkb2MgPSBcImRvY3VtZW50XCIgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuZG9jdW1lbnQgOiB2b2lkIDA7XG4gIHJldHVybiBkb2MgJiYgdHlwZW9mIGRvYyA9PSBcIm9iamVjdFwiICYmIFwiYmFzZVVSSVwiIGluIGRvYyAmJiB0eXBlb2YgZG9jLmJhc2VVUkkgPT0gXCJzdHJpbmdcIiA/IGRvYy5iYXNlVVJJIDogdm9pZCAwO1xufVxuZXhwb3J0IHtcbiAgRXJyb3JFdmVudCxcbiAgRXZlbnRTb3VyY2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/eventsource/dist/index.js\n");

/***/ })

};
;