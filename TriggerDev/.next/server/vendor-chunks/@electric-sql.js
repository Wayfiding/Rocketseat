"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@electric-sql";
exports.ids = ["vendor-chunks/@electric-sql"];
exports.modules = {

/***/ "(rsc)/./node_modules/@electric-sql/client/dist/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@electric-sql/client/dist/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackoffDefaults: () => (/* binding */ BackoffDefaults),\n/* harmony export */   FetchError: () => (/* binding */ FetchError),\n/* harmony export */   Shape: () => (/* binding */ Shape),\n/* harmony export */   ShapeStream: () => (/* binding */ ShapeStream),\n/* harmony export */   isChangeMessage: () => (/* binding */ isChangeMessage),\n/* harmony export */   isControlMessage: () => (/* binding */ isControlMessage)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/error.ts\nvar FetchError = class _FetchError extends Error {\n  constructor(status, text, json, headers, url, message) {\n    super(\n      message || `HTTP Error ${status} at ${url}: ${text != null ? text : JSON.stringify(json)}`\n    );\n    this.url = url;\n    this.name = `FetchError`;\n    this.status = status;\n    this.text = text;\n    this.json = json;\n    this.headers = headers;\n  }\n  static fromResponse(response, url) {\n    return __async(this, null, function* () {\n      const status = response.status;\n      const headers = Object.fromEntries([...response.headers.entries()]);\n      let text = void 0;\n      let json = void 0;\n      const contentType = response.headers.get(`content-type`);\n      if (contentType && contentType.includes(`application/json`)) {\n        json = yield response.json();\n      } else {\n        text = yield response.text();\n      }\n      return new _FetchError(status, text, json, headers, url);\n    });\n  }\n};\nvar FetchBackoffAbortError = class extends Error {\n  constructor() {\n    super(`Fetch with backoff aborted`);\n    this.name = `FetchBackoffAbortError`;\n  }\n};\nvar MissingShapeUrlError = class extends Error {\n  constructor() {\n    super(`Invalid shape options: missing required url parameter`);\n    this.name = `MissingShapeUrlError`;\n  }\n};\nvar InvalidSignalError = class extends Error {\n  constructor() {\n    super(`Invalid signal option. It must be an instance of AbortSignal.`);\n    this.name = `InvalidSignalError`;\n  }\n};\nvar MissingShapeHandleError = class extends Error {\n  constructor() {\n    super(\n      `shapeHandle is required if this isn't an initial fetch (i.e. offset > -1)`\n    );\n    this.name = `MissingShapeHandleError`;\n  }\n};\nvar ReservedParamError = class extends Error {\n  constructor(reservedParams) {\n    super(\n      `Cannot use reserved Electric parameter names in custom params: ${reservedParams.join(`, `)}`\n    );\n    this.name = `ReservedParamError`;\n  }\n};\nvar ParserNullValueError = class extends Error {\n  constructor(columnName) {\n    super(`Column \"${columnName != null ? columnName : `unknown`}\" does not allow NULL values`);\n    this.name = `ParserNullValueError`;\n  }\n};\nvar MissingHeadersError = class extends Error {\n  constructor(url, missingHeaders) {\n    let msg = `The response for the shape request to ${url} didn't include the following required headers:\n`;\n    missingHeaders.forEach((h) => {\n      msg += `- ${h}\n`;\n    });\n    msg += `\nThis is often due to a proxy not setting CORS correctly so that all Electric headers can be read by the client.`;\n    msg += `\nFor more information visit the troubleshooting guide: /docs/guides/troubleshooting/missing-headers`;\n    super(msg);\n  }\n};\n\n// src/parser.ts\nvar parseNumber = (value) => Number(value);\nvar parseBool = (value) => value === `true` || value === `t`;\nvar parseBigInt = (value) => BigInt(value);\nvar parseJson = (value) => JSON.parse(value);\nvar identityParser = (v) => v;\nvar defaultParser = {\n  int2: parseNumber,\n  int4: parseNumber,\n  int8: parseBigInt,\n  bool: parseBool,\n  float4: parseNumber,\n  float8: parseNumber,\n  json: parseJson,\n  jsonb: parseJson\n};\nfunction pgArrayParser(value, parser) {\n  let i = 0;\n  let char = null;\n  let str = ``;\n  let quoted = false;\n  let last = 0;\n  let p = void 0;\n  function loop(x) {\n    const xs = [];\n    for (; i < x.length; i++) {\n      char = x[i];\n      if (quoted) {\n        if (char === `\\\\`) {\n          str += x[++i];\n        } else if (char === `\"`) {\n          xs.push(parser ? parser(str) : str);\n          str = ``;\n          quoted = x[i + 1] === `\"`;\n          last = i + 2;\n        } else {\n          str += char;\n        }\n      } else if (char === `\"`) {\n        quoted = true;\n      } else if (char === `{`) {\n        last = ++i;\n        xs.push(loop(x));\n      } else if (char === `}`) {\n        quoted = false;\n        last < i && xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i));\n        last = i + 1;\n        break;\n      } else if (char === `,` && p !== `}` && p !== `\"`) {\n        xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i));\n        last = i + 1;\n      }\n      p = char;\n    }\n    last < i && xs.push(parser ? parser(x.slice(last, i + 1)) : x.slice(last, i + 1));\n    return xs;\n  }\n  return loop(value)[0];\n}\nvar MessageParser = class {\n  constructor(parser) {\n    this.parser = __spreadValues(__spreadValues({}, defaultParser), parser);\n  }\n  parse(messages, schema) {\n    return JSON.parse(messages, (key, value) => {\n      if (key === `value` && typeof value === `object` && value !== null) {\n        const row = value;\n        Object.keys(row).forEach((key2) => {\n          row[key2] = this.parseRow(key2, row[key2], schema);\n        });\n      }\n      return value;\n    });\n  }\n  // Parses the message values using the provided parser based on the schema information\n  parseRow(key, value, schema) {\n    var _b;\n    const columnInfo = schema[key];\n    if (!columnInfo) {\n      return value;\n    }\n    const _a = columnInfo, { type: typ, dims: dimensions } = _a, additionalInfo = __objRest(_a, [\"type\", \"dims\"]);\n    const typeParser = (_b = this.parser[typ]) != null ? _b : identityParser;\n    const parser = makeNullableParser(typeParser, columnInfo, key);\n    if (dimensions && dimensions > 0) {\n      const nullablePgArrayParser = makeNullableParser(\n        (value2, _) => pgArrayParser(value2, parser),\n        columnInfo,\n        key\n      );\n      return nullablePgArrayParser(value);\n    }\n    return parser(value, additionalInfo);\n  }\n};\nfunction makeNullableParser(parser, columnInfo, columnName) {\n  var _a;\n  const isNullable = !((_a = columnInfo.not_null) != null ? _a : false);\n  return (value) => {\n    if (isPgNull(value)) {\n      if (!isNullable) {\n        throw new ParserNullValueError(columnName != null ? columnName : `unknown`);\n      }\n      return null;\n    }\n    return parser(value, columnInfo);\n  };\n}\nfunction isPgNull(value) {\n  return value === null || value === `NULL`;\n}\n\n// src/helpers.ts\nfunction isChangeMessage(message) {\n  return `key` in message;\n}\nfunction isControlMessage(message) {\n  return !isChangeMessage(message);\n}\nfunction isUpToDateMessage(message) {\n  return isControlMessage(message) && message.headers.control === `up-to-date`;\n}\n\n// src/constants.ts\nvar LIVE_CACHE_BUSTER_HEADER = `electric-cursor`;\nvar SHAPE_HANDLE_HEADER = `electric-handle`;\nvar CHUNK_LAST_OFFSET_HEADER = `electric-offset`;\nvar SHAPE_SCHEMA_HEADER = `electric-schema`;\nvar CHUNK_UP_TO_DATE_HEADER = `electric-up-to-date`;\nvar COLUMNS_QUERY_PARAM = `columns`;\nvar LIVE_CACHE_BUSTER_QUERY_PARAM = `cursor`;\nvar SHAPE_HANDLE_QUERY_PARAM = `handle`;\nvar LIVE_QUERY_PARAM = `live`;\nvar OFFSET_QUERY_PARAM = `offset`;\nvar TABLE_QUERY_PARAM = `table`;\nvar WHERE_QUERY_PARAM = `where`;\nvar REPLICA_PARAM = `replica`;\n\n// src/fetch.ts\nvar HTTP_RETRY_STATUS_CODES = [429];\nvar BackoffDefaults = {\n  initialDelay: 100,\n  maxDelay: 1e4,\n  multiplier: 1.3\n};\nfunction createFetchWithBackoff(fetchClient, backoffOptions = BackoffDefaults) {\n  const {\n    initialDelay,\n    maxDelay,\n    multiplier,\n    debug = false,\n    onFailedAttempt\n  } = backoffOptions;\n  return (...args) => __async(this, null, function* () {\n    var _a;\n    const url = args[0];\n    const options = args[1];\n    let delay = initialDelay;\n    let attempt = 0;\n    while (true) {\n      try {\n        const result = yield fetchClient(...args);\n        if (result.ok) return result;\n        else throw yield FetchError.fromResponse(result, url.toString());\n      } catch (e) {\n        onFailedAttempt == null ? void 0 : onFailedAttempt();\n        if ((_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.aborted) {\n          throw new FetchBackoffAbortError();\n        } else if (e instanceof FetchError && !HTTP_RETRY_STATUS_CODES.includes(e.status) && e.status >= 400 && e.status < 500) {\n          throw e;\n        } else {\n          yield new Promise((resolve) => setTimeout(resolve, delay));\n          delay = Math.min(delay * multiplier, maxDelay);\n          if (debug) {\n            attempt++;\n            console.log(`Retry attempt #${attempt} after ${delay}ms`);\n          }\n        }\n      }\n    }\n  });\n}\nvar ChunkPrefetchDefaults = {\n  maxChunksToPrefetch: 2\n};\nfunction createFetchWithChunkBuffer(fetchClient, prefetchOptions = ChunkPrefetchDefaults) {\n  const { maxChunksToPrefetch } = prefetchOptions;\n  let prefetchQueue;\n  const prefetchClient = (...args) => __async(this, null, function* () {\n    const url = args[0].toString();\n    const prefetchedRequest = prefetchQueue == null ? void 0 : prefetchQueue.consume(...args);\n    if (prefetchedRequest) {\n      return prefetchedRequest;\n    }\n    prefetchQueue == null ? void 0 : prefetchQueue.abort();\n    const response = yield fetchClient(...args);\n    const nextUrl = getNextChunkUrl(url, response);\n    if (nextUrl) {\n      prefetchQueue = new PrefetchQueue({\n        fetchClient,\n        maxPrefetchedRequests: maxChunksToPrefetch,\n        url: nextUrl,\n        requestInit: args[1]\n      });\n    }\n    return response;\n  });\n  return prefetchClient;\n}\nvar requiredElectricResponseHeaders = [\n  `electric-offset`,\n  `electric-handle`\n];\nvar requiredLiveResponseHeaders = [`electric-cursor`];\nvar requiredNonLiveResponseHeaders = [`electric-schema`];\nfunction createFetchWithResponseHeadersCheck(fetchClient) {\n  return (...args) => __async(this, null, function* () {\n    const response = yield fetchClient(...args);\n    if (response.ok) {\n      const headers = response.headers;\n      const missingHeaders = [];\n      const addMissingHeaders = (requiredHeaders) => missingHeaders.push(...requiredHeaders.filter((h) => !headers.has(h)));\n      addMissingHeaders(requiredElectricResponseHeaders);\n      const input = args[0];\n      const urlString = input.toString();\n      const url = new URL(urlString);\n      if (url.searchParams.get(LIVE_QUERY_PARAM) === `true`) {\n        addMissingHeaders(requiredLiveResponseHeaders);\n      }\n      if (!url.searchParams.has(LIVE_QUERY_PARAM) || url.searchParams.get(LIVE_QUERY_PARAM) === `false`) {\n        addMissingHeaders(requiredNonLiveResponseHeaders);\n      }\n      if (missingHeaders.length > 0) {\n        throw new MissingHeadersError(urlString, missingHeaders);\n      }\n    }\n    return response;\n  });\n}\nvar _fetchClient, _maxPrefetchedRequests, _prefetchQueue, _queueHeadUrl, _queueTailUrl, _PrefetchQueue_instances, prefetch_fn;\nvar PrefetchQueue = class {\n  constructor(options) {\n    __privateAdd(this, _PrefetchQueue_instances);\n    __privateAdd(this, _fetchClient);\n    __privateAdd(this, _maxPrefetchedRequests);\n    __privateAdd(this, _prefetchQueue, /* @__PURE__ */ new Map());\n    __privateAdd(this, _queueHeadUrl);\n    __privateAdd(this, _queueTailUrl);\n    var _a;\n    __privateSet(this, _fetchClient, (_a = options.fetchClient) != null ? _a : (...args) => fetch(...args));\n    __privateSet(this, _maxPrefetchedRequests, options.maxPrefetchedRequests);\n    __privateSet(this, _queueHeadUrl, options.url.toString());\n    __privateSet(this, _queueTailUrl, __privateGet(this, _queueHeadUrl));\n    __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, options.url, options.requestInit);\n  }\n  abort() {\n    __privateGet(this, _prefetchQueue).forEach(([_, aborter]) => aborter.abort());\n  }\n  consume(...args) {\n    var _a;\n    const url = args[0].toString();\n    const request = (_a = __privateGet(this, _prefetchQueue).get(url)) == null ? void 0 : _a[0];\n    if (!request || url !== __privateGet(this, _queueHeadUrl)) return;\n    __privateGet(this, _prefetchQueue).delete(url);\n    request.then((response) => {\n      const nextUrl = getNextChunkUrl(url, response);\n      __privateSet(this, _queueHeadUrl, nextUrl);\n      if (__privateGet(this, _queueTailUrl) && !__privateGet(this, _prefetchQueue).has(__privateGet(this, _queueTailUrl))) {\n        __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, __privateGet(this, _queueTailUrl), args[1]);\n      }\n    }).catch(() => {\n    });\n    return request;\n  }\n};\n_fetchClient = new WeakMap();\n_maxPrefetchedRequests = new WeakMap();\n_prefetchQueue = new WeakMap();\n_queueHeadUrl = new WeakMap();\n_queueTailUrl = new WeakMap();\n_PrefetchQueue_instances = new WeakSet();\nprefetch_fn = function(...args) {\n  var _a, _b;\n  const url = args[0].toString();\n  if (__privateGet(this, _prefetchQueue).size >= __privateGet(this, _maxPrefetchedRequests)) return;\n  const aborter = new AbortController();\n  try {\n    const request = __privateGet(this, _fetchClient).call(this, url, __spreadProps(__spreadValues({}, (_a = args[1]) != null ? _a : {}), {\n      signal: chainAborter(aborter, (_b = args[1]) == null ? void 0 : _b.signal)\n    }));\n    __privateGet(this, _prefetchQueue).set(url, [request, aborter]);\n    request.then((response) => {\n      if (!response.ok || aborter.signal.aborted) return;\n      const nextUrl = getNextChunkUrl(url, response);\n      if (!nextUrl || nextUrl === url) {\n        __privateSet(this, _queueTailUrl, void 0);\n        return;\n      }\n      __privateSet(this, _queueTailUrl, nextUrl);\n      return __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, nextUrl, args[1]);\n    }).catch(() => {\n    });\n  } catch (_) {\n  }\n};\nfunction getNextChunkUrl(url, res) {\n  const shapeHandle = res.headers.get(SHAPE_HANDLE_HEADER);\n  const lastOffset = res.headers.get(CHUNK_LAST_OFFSET_HEADER);\n  const isUpToDate = res.headers.has(CHUNK_UP_TO_DATE_HEADER);\n  if (!shapeHandle || !lastOffset || isUpToDate) return;\n  const nextUrl = new URL(url);\n  if (nextUrl.searchParams.has(LIVE_QUERY_PARAM)) return;\n  nextUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, shapeHandle);\n  nextUrl.searchParams.set(OFFSET_QUERY_PARAM, lastOffset);\n  nextUrl.searchParams.sort();\n  return nextUrl.toString();\n}\nfunction chainAborter(aborter, sourceSignal) {\n  if (!sourceSignal) return aborter.signal;\n  if (sourceSignal.aborted) aborter.abort();\n  else\n    sourceSignal.addEventListener(`abort`, () => aborter.abort(), {\n      once: true\n    });\n  return aborter.signal;\n}\n\n// src/client.ts\nvar RESERVED_PARAMS = /* @__PURE__ */ new Set([\n  LIVE_CACHE_BUSTER_QUERY_PARAM,\n  SHAPE_HANDLE_QUERY_PARAM,\n  LIVE_QUERY_PARAM,\n  OFFSET_QUERY_PARAM\n]);\nfunction toInternalParams(params) {\n  const result = {};\n  for (const [key, value] of Object.entries(params)) {\n    result[key] = Array.isArray(value) ? value.join(`,`) : value;\n  }\n  return result;\n}\nvar _error, _fetchClient2, _messageParser, _subscribers, _lastOffset, _liveCacheBuster, _lastSyncedAt, _isUpToDate, _connected, _shapeHandle, _schema, _onError, _ShapeStream_instances, start_fn, publish_fn, sendErrorToSubscribers_fn, reset_fn;\nvar ShapeStream = class {\n  constructor(options) {\n    __privateAdd(this, _ShapeStream_instances);\n    __privateAdd(this, _error, null);\n    __privateAdd(this, _fetchClient2);\n    __privateAdd(this, _messageParser);\n    __privateAdd(this, _subscribers, /* @__PURE__ */ new Map());\n    __privateAdd(this, _lastOffset);\n    __privateAdd(this, _liveCacheBuster);\n    // Seconds since our Electric Epoch ðŸ˜Ž\n    __privateAdd(this, _lastSyncedAt);\n    // unix time\n    __privateAdd(this, _isUpToDate, false);\n    __privateAdd(this, _connected, false);\n    __privateAdd(this, _shapeHandle);\n    __privateAdd(this, _schema);\n    __privateAdd(this, _onError);\n    var _a, _b, _c;\n    this.options = __spreadValues({ subscribe: true }, options);\n    validateOptions(this.options);\n    __privateSet(this, _lastOffset, (_a = this.options.offset) != null ? _a : `-1`);\n    __privateSet(this, _liveCacheBuster, ``);\n    __privateSet(this, _shapeHandle, this.options.handle);\n    __privateSet(this, _messageParser, new MessageParser(options.parser));\n    __privateSet(this, _onError, this.options.onError);\n    const baseFetchClient = (_b = options.fetchClient) != null ? _b : (...args) => fetch(...args);\n    const fetchWithBackoffClient = createFetchWithBackoff(baseFetchClient, __spreadProps(__spreadValues({}, (_c = options.backoffOptions) != null ? _c : BackoffDefaults), {\n      onFailedAttempt: () => {\n        var _a2, _b2;\n        __privateSet(this, _connected, false);\n        (_b2 = (_a2 = options.backoffOptions) == null ? void 0 : _a2.onFailedAttempt) == null ? void 0 : _b2.call(_a2);\n      }\n    }));\n    __privateSet(this, _fetchClient2, createFetchWithResponseHeadersCheck(\n      createFetchWithChunkBuffer(fetchWithBackoffClient)\n    ));\n    __privateMethod(this, _ShapeStream_instances, start_fn).call(this);\n  }\n  get shapeHandle() {\n    return __privateGet(this, _shapeHandle);\n  }\n  get error() {\n    return __privateGet(this, _error);\n  }\n  get isUpToDate() {\n    return __privateGet(this, _isUpToDate);\n  }\n  get lastOffset() {\n    return __privateGet(this, _lastOffset);\n  }\n  subscribe(callback, onError = () => {\n  }) {\n    const subscriptionId = Math.random();\n    __privateGet(this, _subscribers).set(subscriptionId, [callback, onError]);\n    return () => {\n      __privateGet(this, _subscribers).delete(subscriptionId);\n    };\n  }\n  unsubscribeAll() {\n    __privateGet(this, _subscribers).clear();\n  }\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt() {\n    return __privateGet(this, _lastSyncedAt);\n  }\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced() {\n    if (__privateGet(this, _lastSyncedAt) === void 0) return Infinity;\n    return Date.now() - __privateGet(this, _lastSyncedAt);\n  }\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected() {\n    return __privateGet(this, _connected);\n  }\n  /** True during initial fetch. False afterwise.  */\n  isLoading() {\n    return !__privateGet(this, _isUpToDate);\n  }\n};\n_error = new WeakMap();\n_fetchClient2 = new WeakMap();\n_messageParser = new WeakMap();\n_subscribers = new WeakMap();\n_lastOffset = new WeakMap();\n_liveCacheBuster = new WeakMap();\n_lastSyncedAt = new WeakMap();\n_isUpToDate = new WeakMap();\n_connected = new WeakMap();\n_shapeHandle = new WeakMap();\n_schema = new WeakMap();\n_onError = new WeakMap();\n_ShapeStream_instances = new WeakSet();\nstart_fn = function() {\n  return __async(this, null, function* () {\n    var _a, _b;\n    try {\n      while (!((_a = this.options.signal) == null ? void 0 : _a.aborted) && !__privateGet(this, _isUpToDate) || this.options.subscribe) {\n        const { url, signal } = this.options;\n        const fetchUrl = new URL(url);\n        if (this.options.params) {\n          const reservedParams = Object.keys(this.options.params).filter(\n            (key) => RESERVED_PARAMS.has(key)\n          );\n          if (reservedParams.length > 0) {\n            throw new Error(\n              `Cannot use reserved Electric parameter names in custom params: ${reservedParams.join(`, `)}`\n            );\n          }\n          const params = toInternalParams(this.options.params);\n          if (params.table)\n            fetchUrl.searchParams.set(TABLE_QUERY_PARAM, params.table);\n          if (params.where)\n            fetchUrl.searchParams.set(WHERE_QUERY_PARAM, params.where);\n          if (params.columns)\n            fetchUrl.searchParams.set(COLUMNS_QUERY_PARAM, params.columns);\n          if (params.replica)\n            fetchUrl.searchParams.set(REPLICA_PARAM, params.replica);\n          const customParams = __spreadValues({}, params);\n          delete customParams.table;\n          delete customParams.where;\n          delete customParams.columns;\n          delete customParams.replica;\n          for (const [key, value] of Object.entries(customParams)) {\n            fetchUrl.searchParams.set(key, value);\n          }\n        }\n        fetchUrl.searchParams.set(OFFSET_QUERY_PARAM, __privateGet(this, _lastOffset));\n        if (__privateGet(this, _isUpToDate)) {\n          fetchUrl.searchParams.set(LIVE_QUERY_PARAM, `true`);\n          fetchUrl.searchParams.set(\n            LIVE_CACHE_BUSTER_QUERY_PARAM,\n            __privateGet(this, _liveCacheBuster)\n          );\n        }\n        if (__privateGet(this, _shapeHandle)) {\n          fetchUrl.searchParams.set(\n            SHAPE_HANDLE_QUERY_PARAM,\n            __privateGet(this, _shapeHandle)\n          );\n        }\n        fetchUrl.searchParams.sort();\n        let response;\n        try {\n          response = yield __privateGet(this, _fetchClient2).call(this, fetchUrl.toString(), {\n            signal,\n            headers: this.options.headers\n          });\n          __privateSet(this, _connected, true);\n        } catch (e) {\n          if (e instanceof FetchBackoffAbortError) break;\n          if (!(e instanceof FetchError)) throw e;\n          if (e.status == 409) {\n            const newShapeHandle = e.headers[SHAPE_HANDLE_HEADER];\n            __privateMethod(this, _ShapeStream_instances, reset_fn).call(this, newShapeHandle);\n            yield __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, e.json);\n            continue;\n          } else if (e.status >= 400 && e.status < 500) {\n            __privateMethod(this, _ShapeStream_instances, sendErrorToSubscribers_fn).call(this, e);\n            throw e;\n          }\n        }\n        const { headers, status } = response;\n        const shapeHandle = headers.get(SHAPE_HANDLE_HEADER);\n        if (shapeHandle) {\n          __privateSet(this, _shapeHandle, shapeHandle);\n        }\n        const lastOffset = headers.get(CHUNK_LAST_OFFSET_HEADER);\n        if (lastOffset) {\n          __privateSet(this, _lastOffset, lastOffset);\n        }\n        const liveCacheBuster = headers.get(LIVE_CACHE_BUSTER_HEADER);\n        if (liveCacheBuster) {\n          __privateSet(this, _liveCacheBuster, liveCacheBuster);\n        }\n        const getSchema = () => {\n          const schemaHeader = headers.get(SHAPE_SCHEMA_HEADER);\n          return schemaHeader ? JSON.parse(schemaHeader) : {};\n        };\n        __privateSet(this, _schema, (_b = __privateGet(this, _schema)) != null ? _b : getSchema());\n        const messages = status === 204 ? `[]` : yield response.text();\n        if (status === 204) {\n          __privateSet(this, _lastSyncedAt, Date.now());\n        }\n        const batch = __privateGet(this, _messageParser).parse(messages, __privateGet(this, _schema));\n        if (batch.length > 0) {\n          const lastMessage = batch[batch.length - 1];\n          if (isUpToDateMessage(lastMessage)) {\n            __privateSet(this, _lastSyncedAt, Date.now());\n            __privateSet(this, _isUpToDate, true);\n          }\n          yield __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, batch);\n        }\n      }\n    } catch (err) {\n      __privateSet(this, _error, err);\n      if (__privateGet(this, _onError)) {\n        const retryOpts = yield __privateGet(this, _onError).call(this, err);\n        if (typeof retryOpts === `object`) {\n          __privateMethod(this, _ShapeStream_instances, reset_fn).call(this);\n          if (`params` in retryOpts) {\n            this.options.params = retryOpts.params;\n          }\n          if (`headers` in retryOpts) {\n            this.options.headers = retryOpts.headers;\n          }\n          __privateMethod(this, _ShapeStream_instances, start_fn).call(this);\n        }\n        return;\n      }\n      throw err;\n    } finally {\n      __privateSet(this, _connected, false);\n    }\n  });\n};\npublish_fn = function(messages) {\n  return __async(this, null, function* () {\n    yield Promise.all(\n      Array.from(__privateGet(this, _subscribers).values()).map((_0) => __async(this, [_0], function* ([callback, __]) {\n        try {\n          yield callback(messages);\n        } catch (err) {\n          queueMicrotask(() => {\n            throw err;\n          });\n        }\n      }))\n    );\n  });\n};\nsendErrorToSubscribers_fn = function(error) {\n  __privateGet(this, _subscribers).forEach(([_, errorFn]) => {\n    errorFn == null ? void 0 : errorFn(error);\n  });\n};\n/**\n * Resets the state of the stream, optionally with a provided\n * shape handle\n */\nreset_fn = function(handle) {\n  __privateSet(this, _lastOffset, `-1`);\n  __privateSet(this, _liveCacheBuster, ``);\n  __privateSet(this, _shapeHandle, handle);\n  __privateSet(this, _isUpToDate, false);\n  __privateSet(this, _connected, false);\n  __privateSet(this, _schema, void 0);\n};\nShapeStream.Replica = {\n  FULL: `full`,\n  DEFAULT: `default`\n};\nfunction validateOptions(options) {\n  if (!options.url) {\n    throw new MissingShapeUrlError();\n  }\n  if (options.signal && !(options.signal instanceof AbortSignal)) {\n    throw new InvalidSignalError();\n  }\n  if (options.offset !== void 0 && options.offset !== `-1` && !options.handle) {\n    throw new MissingShapeHandleError();\n  }\n  if (options.params) {\n    const reservedParams = Object.keys(options.params).filter(\n      (key) => RESERVED_PARAMS.has(key)\n    );\n    if (reservedParams.length > 0) {\n      throw new ReservedParamError(reservedParams);\n    }\n  }\n  return;\n}\n\n// src/shape.ts\nvar _data, _subscribers2, _hasNotifiedSubscribersUpToDate, _error2, _Shape_instances, process_fn, handleError_fn, notify_fn;\nvar Shape = class {\n  constructor(stream) {\n    __privateAdd(this, _Shape_instances);\n    __privateAdd(this, _data, /* @__PURE__ */ new Map());\n    __privateAdd(this, _subscribers2, /* @__PURE__ */ new Map());\n    __privateAdd(this, _hasNotifiedSubscribersUpToDate, false);\n    __privateAdd(this, _error2, false);\n    this.stream = stream;\n    this.stream.subscribe(\n      __privateMethod(this, _Shape_instances, process_fn).bind(this),\n      __privateMethod(this, _Shape_instances, handleError_fn).bind(this)\n    );\n  }\n  get isUpToDate() {\n    return this.stream.isUpToDate;\n  }\n  get lastOffset() {\n    return this.stream.lastOffset;\n  }\n  get handle() {\n    return this.stream.shapeHandle;\n  }\n  get rows() {\n    return this.value.then((v) => Array.from(v.values()));\n  }\n  get currentRows() {\n    return Array.from(this.currentValue.values());\n  }\n  get value() {\n    return new Promise((resolve, reject) => {\n      if (this.stream.isUpToDate) {\n        resolve(this.currentValue);\n      } else {\n        const unsubscribe = this.subscribe(({ value }) => {\n          unsubscribe();\n          if (__privateGet(this, _error2)) reject(__privateGet(this, _error2));\n          resolve(value);\n        });\n      }\n    });\n  }\n  get currentValue() {\n    return __privateGet(this, _data);\n  }\n  get error() {\n    return __privateGet(this, _error2);\n  }\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt() {\n    return this.stream.lastSyncedAt();\n  }\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced() {\n    return this.stream.lastSynced();\n  }\n  /** True during initial fetch. False afterwise.  */\n  isLoading() {\n    return this.stream.isLoading();\n  }\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected() {\n    return this.stream.isConnected();\n  }\n  subscribe(callback) {\n    const subscriptionId = Math.random();\n    __privateGet(this, _subscribers2).set(subscriptionId, callback);\n    return () => {\n      __privateGet(this, _subscribers2).delete(subscriptionId);\n    };\n  }\n  unsubscribeAll() {\n    __privateGet(this, _subscribers2).clear();\n  }\n  get numSubscribers() {\n    return __privateGet(this, _subscribers2).size;\n  }\n};\n_data = new WeakMap();\n_subscribers2 = new WeakMap();\n_hasNotifiedSubscribersUpToDate = new WeakMap();\n_error2 = new WeakMap();\n_Shape_instances = new WeakSet();\nprocess_fn = function(messages) {\n  let dataMayHaveChanged = false;\n  let isUpToDate = false;\n  let newlyUpToDate = false;\n  messages.forEach((message) => {\n    if (isChangeMessage(message)) {\n      dataMayHaveChanged = [`insert`, `update`, `delete`].includes(\n        message.headers.operation\n      );\n      switch (message.headers.operation) {\n        case `insert`:\n          __privateGet(this, _data).set(message.key, message.value);\n          break;\n        case `update`:\n          __privateGet(this, _data).set(message.key, __spreadValues(__spreadValues({}, __privateGet(this, _data).get(message.key)), message.value));\n          break;\n        case `delete`:\n          __privateGet(this, _data).delete(message.key);\n          break;\n      }\n    }\n    if (isControlMessage(message)) {\n      switch (message.headers.control) {\n        case `up-to-date`:\n          isUpToDate = true;\n          if (!__privateGet(this, _hasNotifiedSubscribersUpToDate)) {\n            newlyUpToDate = true;\n          }\n          break;\n        case `must-refetch`:\n          __privateGet(this, _data).clear();\n          __privateSet(this, _error2, false);\n          __privateSet(this, _hasNotifiedSubscribersUpToDate, false);\n          isUpToDate = false;\n          newlyUpToDate = false;\n          break;\n      }\n    }\n  });\n  if (newlyUpToDate || isUpToDate && dataMayHaveChanged) {\n    __privateSet(this, _hasNotifiedSubscribersUpToDate, true);\n    __privateMethod(this, _Shape_instances, notify_fn).call(this);\n  }\n};\nhandleError_fn = function(e) {\n  if (e instanceof FetchError) {\n    __privateSet(this, _error2, e);\n    __privateMethod(this, _Shape_instances, notify_fn).call(this);\n  }\n};\nnotify_fn = function() {\n  __privateGet(this, _subscribers2).forEach((callback) => {\n    callback({ value: this.currentValue, rows: this.currentRows });\n  });\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsZWN0cmljLXNxbC9jbGllbnQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVEsS0FBSyxJQUFJLElBQUksMkNBQTJDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLDBCQUEwQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQTRDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsS0FBSztBQUM1RDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRLG9CQUFvQjtBQUM1QjtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTLFFBQVEsTUFBTTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLGtDQUFrQztBQUN0STtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLDBCQUEwQjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQWtEO0FBQ2pFLEdBQUc7QUFDSDtBQVFFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL2FsYmVydG8vRG9jdW1lbnRvcy9EZXNlbnZvbHZpbWVudG8gV2ViL1JvY2tldHNlYXQvVHJpZ2dlckRldi9ub2RlX21vZHVsZXMvQGVsZWN0cmljLXNxbC9jbGllbnQvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX190eXBlRXJyb3IgPSAobXNnKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihtc2cpO1xufTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4gbWVtYmVyLmhhcyhvYmopIHx8IF9fdHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaikpO1xudmFyIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IG1lbWJlci5oYXMob2JqKSA/IF9fdHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKSA6IG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSwgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpLCB2YWx1ZSk7XG52YXIgX19wcml2YXRlTWV0aG9kID0gKG9iaiwgbWVtYmVyLCBtZXRob2QpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKSwgbWV0aG9kKTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG5cbi8vIHNyYy9lcnJvci50c1xudmFyIEZldGNoRXJyb3IgPSBjbGFzcyBfRmV0Y2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzLCB0ZXh0LCBqc29uLCBoZWFkZXJzLCB1cmwsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcihcbiAgICAgIG1lc3NhZ2UgfHwgYEhUVFAgRXJyb3IgJHtzdGF0dXN9IGF0ICR7dXJsfTogJHt0ZXh0ICE9IG51bGwgPyB0ZXh0IDogSlNPTi5zdHJpbmdpZnkoanNvbil9YFxuICAgICk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5uYW1lID0gYEZldGNoRXJyb3JgO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICB9XG4gIHN0YXRpYyBmcm9tUmVzcG9uc2UocmVzcG9uc2UsIHVybCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBzdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmZyb21FbnRyaWVzKFsuLi5yZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKV0pO1xuICAgICAgbGV0IHRleHQgPSB2b2lkIDA7XG4gICAgICBsZXQganNvbiA9IHZvaWQgMDtcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoYGNvbnRlbnQtdHlwZWApO1xuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKGBhcHBsaWNhdGlvbi9qc29uYCkpIHtcbiAgICAgICAganNvbiA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSB5aWVsZCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IF9GZXRjaEVycm9yKHN0YXR1cywgdGV4dCwganNvbiwgaGVhZGVycywgdXJsKTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBGZXRjaEJhY2tvZmZBYm9ydEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGBGZXRjaCB3aXRoIGJhY2tvZmYgYWJvcnRlZGApO1xuICAgIHRoaXMubmFtZSA9IGBGZXRjaEJhY2tvZmZBYm9ydEVycm9yYDtcbiAgfVxufTtcbnZhciBNaXNzaW5nU2hhcGVVcmxFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgSW52YWxpZCBzaGFwZSBvcHRpb25zOiBtaXNzaW5nIHJlcXVpcmVkIHVybCBwYXJhbWV0ZXJgKTtcbiAgICB0aGlzLm5hbWUgPSBgTWlzc2luZ1NoYXBlVXJsRXJyb3JgO1xuICB9XG59O1xudmFyIEludmFsaWRTaWduYWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgSW52YWxpZCBzaWduYWwgb3B0aW9uLiBJdCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEFib3J0U2lnbmFsLmApO1xuICAgIHRoaXMubmFtZSA9IGBJbnZhbGlkU2lnbmFsRXJyb3JgO1xuICB9XG59O1xudmFyIE1pc3NpbmdTaGFwZUhhbmRsZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFxuICAgICAgYHNoYXBlSGFuZGxlIGlzIHJlcXVpcmVkIGlmIHRoaXMgaXNuJ3QgYW4gaW5pdGlhbCBmZXRjaCAoaS5lLiBvZmZzZXQgPiAtMSlgXG4gICAgKTtcbiAgICB0aGlzLm5hbWUgPSBgTWlzc2luZ1NoYXBlSGFuZGxlRXJyb3JgO1xuICB9XG59O1xudmFyIFJlc2VydmVkUGFyYW1FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZXNlcnZlZFBhcmFtcykge1xuICAgIHN1cGVyKFxuICAgICAgYENhbm5vdCB1c2UgcmVzZXJ2ZWQgRWxlY3RyaWMgcGFyYW1ldGVyIG5hbWVzIGluIGN1c3RvbSBwYXJhbXM6ICR7cmVzZXJ2ZWRQYXJhbXMuam9pbihgLCBgKX1gXG4gICAgKTtcbiAgICB0aGlzLm5hbWUgPSBgUmVzZXJ2ZWRQYXJhbUVycm9yYDtcbiAgfVxufTtcbnZhciBQYXJzZXJOdWxsVmFsdWVFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2x1bW5OYW1lKSB7XG4gICAgc3VwZXIoYENvbHVtbiBcIiR7Y29sdW1uTmFtZSAhPSBudWxsID8gY29sdW1uTmFtZSA6IGB1bmtub3duYH1cIiBkb2VzIG5vdCBhbGxvdyBOVUxMIHZhbHVlc2ApO1xuICAgIHRoaXMubmFtZSA9IGBQYXJzZXJOdWxsVmFsdWVFcnJvcmA7XG4gIH1cbn07XG52YXIgTWlzc2luZ0hlYWRlcnNFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih1cmwsIG1pc3NpbmdIZWFkZXJzKSB7XG4gICAgbGV0IG1zZyA9IGBUaGUgcmVzcG9uc2UgZm9yIHRoZSBzaGFwZSByZXF1ZXN0IHRvICR7dXJsfSBkaWRuJ3QgaW5jbHVkZSB0aGUgZm9sbG93aW5nIHJlcXVpcmVkIGhlYWRlcnM6XG5gO1xuICAgIG1pc3NpbmdIZWFkZXJzLmZvckVhY2goKGgpID0+IHtcbiAgICAgIG1zZyArPSBgLSAke2h9XG5gO1xuICAgIH0pO1xuICAgIG1zZyArPSBgXG5UaGlzIGlzIG9mdGVuIGR1ZSB0byBhIHByb3h5IG5vdCBzZXR0aW5nIENPUlMgY29ycmVjdGx5IHNvIHRoYXQgYWxsIEVsZWN0cmljIGhlYWRlcnMgY2FuIGJlIHJlYWQgYnkgdGhlIGNsaWVudC5gO1xuICAgIG1zZyArPSBgXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiB2aXNpdCB0aGUgdHJvdWJsZXNob290aW5nIGd1aWRlOiAvZG9jcy9ndWlkZXMvdHJvdWJsZXNob290aW5nL21pc3NpbmctaGVhZGVyc2A7XG4gICAgc3VwZXIobXNnKTtcbiAgfVxufTtcblxuLy8gc3JjL3BhcnNlci50c1xudmFyIHBhcnNlTnVtYmVyID0gKHZhbHVlKSA9PiBOdW1iZXIodmFsdWUpO1xudmFyIHBhcnNlQm9vbCA9ICh2YWx1ZSkgPT4gdmFsdWUgPT09IGB0cnVlYCB8fCB2YWx1ZSA9PT0gYHRgO1xudmFyIHBhcnNlQmlnSW50ID0gKHZhbHVlKSA9PiBCaWdJbnQodmFsdWUpO1xudmFyIHBhcnNlSnNvbiA9ICh2YWx1ZSkgPT4gSlNPTi5wYXJzZSh2YWx1ZSk7XG52YXIgaWRlbnRpdHlQYXJzZXIgPSAodikgPT4gdjtcbnZhciBkZWZhdWx0UGFyc2VyID0ge1xuICBpbnQyOiBwYXJzZU51bWJlcixcbiAgaW50NDogcGFyc2VOdW1iZXIsXG4gIGludDg6IHBhcnNlQmlnSW50LFxuICBib29sOiBwYXJzZUJvb2wsXG4gIGZsb2F0NDogcGFyc2VOdW1iZXIsXG4gIGZsb2F0ODogcGFyc2VOdW1iZXIsXG4gIGpzb246IHBhcnNlSnNvbixcbiAganNvbmI6IHBhcnNlSnNvblxufTtcbmZ1bmN0aW9uIHBnQXJyYXlQYXJzZXIodmFsdWUsIHBhcnNlcikge1xuICBsZXQgaSA9IDA7XG4gIGxldCBjaGFyID0gbnVsbDtcbiAgbGV0IHN0ciA9IGBgO1xuICBsZXQgcXVvdGVkID0gZmFsc2U7XG4gIGxldCBsYXN0ID0gMDtcbiAgbGV0IHAgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIGxvb3AoeCkge1xuICAgIGNvbnN0IHhzID0gW107XG4gICAgZm9yICg7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyID0geFtpXTtcbiAgICAgIGlmIChxdW90ZWQpIHtcbiAgICAgICAgaWYgKGNoYXIgPT09IGBcXFxcYCkge1xuICAgICAgICAgIHN0ciArPSB4WysraV07XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gYFwiYCkge1xuICAgICAgICAgIHhzLnB1c2gocGFyc2VyID8gcGFyc2VyKHN0cikgOiBzdHIpO1xuICAgICAgICAgIHN0ciA9IGBgO1xuICAgICAgICAgIHF1b3RlZCA9IHhbaSArIDFdID09PSBgXCJgO1xuICAgICAgICAgIGxhc3QgPSBpICsgMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgKz0gY2hhcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBgXCJgKSB7XG4gICAgICAgIHF1b3RlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IGB7YCkge1xuICAgICAgICBsYXN0ID0gKytpO1xuICAgICAgICB4cy5wdXNoKGxvb3AoeCkpO1xuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBgfWApIHtcbiAgICAgICAgcXVvdGVkID0gZmFsc2U7XG4gICAgICAgIGxhc3QgPCBpICYmIHhzLnB1c2gocGFyc2VyID8gcGFyc2VyKHguc2xpY2UobGFzdCwgaSkpIDogeC5zbGljZShsYXN0LCBpKSk7XG4gICAgICAgIGxhc3QgPSBpICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IGAsYCAmJiBwICE9PSBgfWAgJiYgcCAhPT0gYFwiYCkge1xuICAgICAgICB4cy5wdXNoKHBhcnNlciA/IHBhcnNlcih4LnNsaWNlKGxhc3QsIGkpKSA6IHguc2xpY2UobGFzdCwgaSkpO1xuICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgICB9XG4gICAgICBwID0gY2hhcjtcbiAgICB9XG4gICAgbGFzdCA8IGkgJiYgeHMucHVzaChwYXJzZXIgPyBwYXJzZXIoeC5zbGljZShsYXN0LCBpICsgMSkpIDogeC5zbGljZShsYXN0LCBpICsgMSkpO1xuICAgIHJldHVybiB4cztcbiAgfVxuICByZXR1cm4gbG9vcCh2YWx1ZSlbMF07XG59XG52YXIgTWVzc2FnZVBhcnNlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVmYXVsdFBhcnNlciksIHBhcnNlcik7XG4gIH1cbiAgcGFyc2UobWVzc2FnZXMsIHNjaGVtYSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKG1lc3NhZ2VzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gYHZhbHVlYCAmJiB0eXBlb2YgdmFsdWUgPT09IGBvYmplY3RgICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHZhbHVlO1xuICAgICAgICBPYmplY3Qua2V5cyhyb3cpLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgICAgICByb3dba2V5Ml0gPSB0aGlzLnBhcnNlUm93KGtleTIsIHJvd1trZXkyXSwgc2NoZW1hKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gIH1cbiAgLy8gUGFyc2VzIHRoZSBtZXNzYWdlIHZhbHVlcyB1c2luZyB0aGUgcHJvdmlkZWQgcGFyc2VyIGJhc2VkIG9uIHRoZSBzY2hlbWEgaW5mb3JtYXRpb25cbiAgcGFyc2VSb3coa2V5LCB2YWx1ZSwgc2NoZW1hKSB7XG4gICAgdmFyIF9iO1xuICAgIGNvbnN0IGNvbHVtbkluZm8gPSBzY2hlbWFba2V5XTtcbiAgICBpZiAoIWNvbHVtbkluZm8pIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgX2EgPSBjb2x1bW5JbmZvLCB7IHR5cGU6IHR5cCwgZGltczogZGltZW5zaW9ucyB9ID0gX2EsIGFkZGl0aW9uYWxJbmZvID0gX19vYmpSZXN0KF9hLCBbXCJ0eXBlXCIsIFwiZGltc1wiXSk7XG4gICAgY29uc3QgdHlwZVBhcnNlciA9IChfYiA9IHRoaXMucGFyc2VyW3R5cF0pICE9IG51bGwgPyBfYiA6IGlkZW50aXR5UGFyc2VyO1xuICAgIGNvbnN0IHBhcnNlciA9IG1ha2VOdWxsYWJsZVBhcnNlcih0eXBlUGFyc2VyLCBjb2x1bW5JbmZvLCBrZXkpO1xuICAgIGlmIChkaW1lbnNpb25zICYmIGRpbWVuc2lvbnMgPiAwKSB7XG4gICAgICBjb25zdCBudWxsYWJsZVBnQXJyYXlQYXJzZXIgPSBtYWtlTnVsbGFibGVQYXJzZXIoXG4gICAgICAgICh2YWx1ZTIsIF8pID0+IHBnQXJyYXlQYXJzZXIodmFsdWUyLCBwYXJzZXIpLFxuICAgICAgICBjb2x1bW5JbmZvLFxuICAgICAgICBrZXlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbGFibGVQZ0FycmF5UGFyc2VyKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlcih2YWx1ZSwgYWRkaXRpb25hbEluZm8pO1xuICB9XG59O1xuZnVuY3Rpb24gbWFrZU51bGxhYmxlUGFyc2VyKHBhcnNlciwgY29sdW1uSW5mbywgY29sdW1uTmFtZSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGlzTnVsbGFibGUgPSAhKChfYSA9IGNvbHVtbkluZm8ubm90X251bGwpICE9IG51bGwgPyBfYSA6IGZhbHNlKTtcbiAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgIGlmIChpc1BnTnVsbCh2YWx1ZSkpIHtcbiAgICAgIGlmICghaXNOdWxsYWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VyTnVsbFZhbHVlRXJyb3IoY29sdW1uTmFtZSAhPSBudWxsID8gY29sdW1uTmFtZSA6IGB1bmtub3duYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlcih2YWx1ZSwgY29sdW1uSW5mbyk7XG4gIH07XG59XG5mdW5jdGlvbiBpc1BnTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IGBOVUxMYDtcbn1cblxuLy8gc3JjL2hlbHBlcnMudHNcbmZ1bmN0aW9uIGlzQ2hhbmdlTWVzc2FnZShtZXNzYWdlKSB7XG4gIHJldHVybiBga2V5YCBpbiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gaXNDb250cm9sTWVzc2FnZShtZXNzYWdlKSB7XG4gIHJldHVybiAhaXNDaGFuZ2VNZXNzYWdlKG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gaXNVcFRvRGF0ZU1lc3NhZ2UobWVzc2FnZSkge1xuICByZXR1cm4gaXNDb250cm9sTWVzc2FnZShtZXNzYWdlKSAmJiBtZXNzYWdlLmhlYWRlcnMuY29udHJvbCA9PT0gYHVwLXRvLWRhdGVgO1xufVxuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgTElWRV9DQUNIRV9CVVNURVJfSEVBREVSID0gYGVsZWN0cmljLWN1cnNvcmA7XG52YXIgU0hBUEVfSEFORExFX0hFQURFUiA9IGBlbGVjdHJpYy1oYW5kbGVgO1xudmFyIENIVU5LX0xBU1RfT0ZGU0VUX0hFQURFUiA9IGBlbGVjdHJpYy1vZmZzZXRgO1xudmFyIFNIQVBFX1NDSEVNQV9IRUFERVIgPSBgZWxlY3RyaWMtc2NoZW1hYDtcbnZhciBDSFVOS19VUF9UT19EQVRFX0hFQURFUiA9IGBlbGVjdHJpYy11cC10by1kYXRlYDtcbnZhciBDT0xVTU5TX1FVRVJZX1BBUkFNID0gYGNvbHVtbnNgO1xudmFyIExJVkVfQ0FDSEVfQlVTVEVSX1FVRVJZX1BBUkFNID0gYGN1cnNvcmA7XG52YXIgU0hBUEVfSEFORExFX1FVRVJZX1BBUkFNID0gYGhhbmRsZWA7XG52YXIgTElWRV9RVUVSWV9QQVJBTSA9IGBsaXZlYDtcbnZhciBPRkZTRVRfUVVFUllfUEFSQU0gPSBgb2Zmc2V0YDtcbnZhciBUQUJMRV9RVUVSWV9QQVJBTSA9IGB0YWJsZWA7XG52YXIgV0hFUkVfUVVFUllfUEFSQU0gPSBgd2hlcmVgO1xudmFyIFJFUExJQ0FfUEFSQU0gPSBgcmVwbGljYWA7XG5cbi8vIHNyYy9mZXRjaC50c1xudmFyIEhUVFBfUkVUUllfU1RBVFVTX0NPREVTID0gWzQyOV07XG52YXIgQmFja29mZkRlZmF1bHRzID0ge1xuICBpbml0aWFsRGVsYXk6IDEwMCxcbiAgbWF4RGVsYXk6IDFlNCxcbiAgbXVsdGlwbGllcjogMS4zXG59O1xuZnVuY3Rpb24gY3JlYXRlRmV0Y2hXaXRoQmFja29mZihmZXRjaENsaWVudCwgYmFja29mZk9wdGlvbnMgPSBCYWNrb2ZmRGVmYXVsdHMpIHtcbiAgY29uc3Qge1xuICAgIGluaXRpYWxEZWxheSxcbiAgICBtYXhEZWxheSxcbiAgICBtdWx0aXBsaWVyLFxuICAgIGRlYnVnID0gZmFsc2UsXG4gICAgb25GYWlsZWRBdHRlbXB0XG4gIH0gPSBiYWNrb2ZmT3B0aW9ucztcbiAgcmV0dXJuICguLi5hcmdzKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHVybCA9IGFyZ3NbMF07XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3NbMV07XG4gICAgbGV0IGRlbGF5ID0gaW5pdGlhbERlbGF5O1xuICAgIGxldCBhdHRlbXB0ID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgZmV0Y2hDbGllbnQoLi4uYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQub2spIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGVsc2UgdGhyb3cgeWllbGQgRmV0Y2hFcnJvci5mcm9tUmVzcG9uc2UocmVzdWx0LCB1cmwudG9TdHJpbmcoKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG9uRmFpbGVkQXR0ZW1wdCA9PSBudWxsID8gdm9pZCAwIDogb25GYWlsZWRBdHRlbXB0KCk7XG4gICAgICAgIGlmICgoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmFib3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRmV0Y2hCYWNrb2ZmQWJvcnRFcnJvcigpO1xuICAgICAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBGZXRjaEVycm9yICYmICFIVFRQX1JFVFJZX1NUQVRVU19DT0RFUy5pbmNsdWRlcyhlLnN0YXR1cykgJiYgZS5zdGF0dXMgPj0gNDAwICYmIGUuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICAgIGRlbGF5ID0gTWF0aC5taW4oZGVsYXkgKiBtdWx0aXBsaWVyLCBtYXhEZWxheSk7XG4gICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICBhdHRlbXB0Kys7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUmV0cnkgYXR0ZW1wdCAjJHthdHRlbXB0fSBhZnRlciAke2RlbGF5fW1zYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbnZhciBDaHVua1ByZWZldGNoRGVmYXVsdHMgPSB7XG4gIG1heENodW5rc1RvUHJlZmV0Y2g6IDJcbn07XG5mdW5jdGlvbiBjcmVhdGVGZXRjaFdpdGhDaHVua0J1ZmZlcihmZXRjaENsaWVudCwgcHJlZmV0Y2hPcHRpb25zID0gQ2h1bmtQcmVmZXRjaERlZmF1bHRzKSB7XG4gIGNvbnN0IHsgbWF4Q2h1bmtzVG9QcmVmZXRjaCB9ID0gcHJlZmV0Y2hPcHRpb25zO1xuICBsZXQgcHJlZmV0Y2hRdWV1ZTtcbiAgY29uc3QgcHJlZmV0Y2hDbGllbnQgPSAoLi4uYXJncykgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHVybCA9IGFyZ3NbMF0udG9TdHJpbmcoKTtcbiAgICBjb25zdCBwcmVmZXRjaGVkUmVxdWVzdCA9IHByZWZldGNoUXVldWUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZWZldGNoUXVldWUuY29uc3VtZSguLi5hcmdzKTtcbiAgICBpZiAocHJlZmV0Y2hlZFJlcXVlc3QpIHtcbiAgICAgIHJldHVybiBwcmVmZXRjaGVkUmVxdWVzdDtcbiAgICB9XG4gICAgcHJlZmV0Y2hRdWV1ZSA9PSBudWxsID8gdm9pZCAwIDogcHJlZmV0Y2hRdWV1ZS5hYm9ydCgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2hDbGllbnQoLi4uYXJncyk7XG4gICAgY29uc3QgbmV4dFVybCA9IGdldE5leHRDaHVua1VybCh1cmwsIHJlc3BvbnNlKTtcbiAgICBpZiAobmV4dFVybCkge1xuICAgICAgcHJlZmV0Y2hRdWV1ZSA9IG5ldyBQcmVmZXRjaFF1ZXVlKHtcbiAgICAgICAgZmV0Y2hDbGllbnQsXG4gICAgICAgIG1heFByZWZldGNoZWRSZXF1ZXN0czogbWF4Q2h1bmtzVG9QcmVmZXRjaCxcbiAgICAgICAgdXJsOiBuZXh0VXJsLFxuICAgICAgICByZXF1ZXN0SW5pdDogYXJnc1sxXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSk7XG4gIHJldHVybiBwcmVmZXRjaENsaWVudDtcbn1cbnZhciByZXF1aXJlZEVsZWN0cmljUmVzcG9uc2VIZWFkZXJzID0gW1xuICBgZWxlY3RyaWMtb2Zmc2V0YCxcbiAgYGVsZWN0cmljLWhhbmRsZWBcbl07XG52YXIgcmVxdWlyZWRMaXZlUmVzcG9uc2VIZWFkZXJzID0gW2BlbGVjdHJpYy1jdXJzb3JgXTtcbnZhciByZXF1aXJlZE5vbkxpdmVSZXNwb25zZUhlYWRlcnMgPSBbYGVsZWN0cmljLXNjaGVtYWBdO1xuZnVuY3Rpb24gY3JlYXRlRmV0Y2hXaXRoUmVzcG9uc2VIZWFkZXJzQ2hlY2soZmV0Y2hDbGllbnQpIHtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaENsaWVudCguLi5hcmdzKTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzO1xuICAgICAgY29uc3QgbWlzc2luZ0hlYWRlcnMgPSBbXTtcbiAgICAgIGNvbnN0IGFkZE1pc3NpbmdIZWFkZXJzID0gKHJlcXVpcmVkSGVhZGVycykgPT4gbWlzc2luZ0hlYWRlcnMucHVzaCguLi5yZXF1aXJlZEhlYWRlcnMuZmlsdGVyKChoKSA9PiAhaGVhZGVycy5oYXMoaCkpKTtcbiAgICAgIGFkZE1pc3NpbmdIZWFkZXJzKHJlcXVpcmVkRWxlY3RyaWNSZXNwb25zZUhlYWRlcnMpO1xuICAgICAgY29uc3QgaW5wdXQgPSBhcmdzWzBdO1xuICAgICAgY29uc3QgdXJsU3RyaW5nID0gaW5wdXQudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodXJsU3RyaW5nKTtcbiAgICAgIGlmICh1cmwuc2VhcmNoUGFyYW1zLmdldChMSVZFX1FVRVJZX1BBUkFNKSA9PT0gYHRydWVgKSB7XG4gICAgICAgIGFkZE1pc3NpbmdIZWFkZXJzKHJlcXVpcmVkTGl2ZVJlc3BvbnNlSGVhZGVycyk7XG4gICAgICB9XG4gICAgICBpZiAoIXVybC5zZWFyY2hQYXJhbXMuaGFzKExJVkVfUVVFUllfUEFSQU0pIHx8IHVybC5zZWFyY2hQYXJhbXMuZ2V0KExJVkVfUVVFUllfUEFSQU0pID09PSBgZmFsc2VgKSB7XG4gICAgICAgIGFkZE1pc3NpbmdIZWFkZXJzKHJlcXVpcmVkTm9uTGl2ZVJlc3BvbnNlSGVhZGVycyk7XG4gICAgICB9XG4gICAgICBpZiAobWlzc2luZ0hlYWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ0hlYWRlcnNFcnJvcih1cmxTdHJpbmcsIG1pc3NpbmdIZWFkZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9KTtcbn1cbnZhciBfZmV0Y2hDbGllbnQsIF9tYXhQcmVmZXRjaGVkUmVxdWVzdHMsIF9wcmVmZXRjaFF1ZXVlLCBfcXVldWVIZWFkVXJsLCBfcXVldWVUYWlsVXJsLCBfUHJlZmV0Y2hRdWV1ZV9pbnN0YW5jZXMsIHByZWZldGNoX2ZuO1xudmFyIFByZWZldGNoUXVldWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX1ByZWZldGNoUXVldWVfaW5zdGFuY2VzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2ZldGNoQ2xpZW50KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21heFByZWZldGNoZWRSZXF1ZXN0cyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wcmVmZXRjaFF1ZXVlLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3F1ZXVlSGVhZFVybCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9xdWV1ZVRhaWxVcmwpO1xuICAgIHZhciBfYTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2ZldGNoQ2xpZW50LCAoX2EgPSBvcHRpb25zLmZldGNoQ2xpZW50KSAhPSBudWxsID8gX2EgOiAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncykpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWF4UHJlZmV0Y2hlZFJlcXVlc3RzLCBvcHRpb25zLm1heFByZWZldGNoZWRSZXF1ZXN0cyk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9xdWV1ZUhlYWRVcmwsIG9wdGlvbnMudXJsLnRvU3RyaW5nKCkpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcXVldWVUYWlsVXJsLCBfX3ByaXZhdGVHZXQodGhpcywgX3F1ZXVlSGVhZFVybCkpO1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfUHJlZmV0Y2hRdWV1ZV9pbnN0YW5jZXMsIHByZWZldGNoX2ZuKS5jYWxsKHRoaXMsIG9wdGlvbnMudXJsLCBvcHRpb25zLnJlcXVlc3RJbml0KTtcbiAgfVxuICBhYm9ydCgpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3ByZWZldGNoUXVldWUpLmZvckVhY2goKFtfLCBhYm9ydGVyXSkgPT4gYWJvcnRlci5hYm9ydCgpKTtcbiAgfVxuICBjb25zdW1lKC4uLmFyZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdXJsID0gYXJnc1swXS50b1N0cmluZygpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSAoX2EgPSBfX3ByaXZhdGVHZXQodGhpcywgX3ByZWZldGNoUXVldWUpLmdldCh1cmwpKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF07XG4gICAgaWYgKCFyZXF1ZXN0IHx8IHVybCAhPT0gX19wcml2YXRlR2V0KHRoaXMsIF9xdWV1ZUhlYWRVcmwpKSByZXR1cm47XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9wcmVmZXRjaFF1ZXVlKS5kZWxldGUodXJsKTtcbiAgICByZXF1ZXN0LnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zdCBuZXh0VXJsID0gZ2V0TmV4dENodW5rVXJsKHVybCwgcmVzcG9uc2UpO1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9xdWV1ZUhlYWRVcmwsIG5leHRVcmwpO1xuICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfcXVldWVUYWlsVXJsKSAmJiAhX19wcml2YXRlR2V0KHRoaXMsIF9wcmVmZXRjaFF1ZXVlKS5oYXMoX19wcml2YXRlR2V0KHRoaXMsIF9xdWV1ZVRhaWxVcmwpKSkge1xuICAgICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX1ByZWZldGNoUXVldWVfaW5zdGFuY2VzLCBwcmVmZXRjaF9mbikuY2FsbCh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX3F1ZXVlVGFpbFVybCksIGFyZ3NbMV0pO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxufTtcbl9mZXRjaENsaWVudCA9IG5ldyBXZWFrTWFwKCk7XG5fbWF4UHJlZmV0Y2hlZFJlcXVlc3RzID0gbmV3IFdlYWtNYXAoKTtcbl9wcmVmZXRjaFF1ZXVlID0gbmV3IFdlYWtNYXAoKTtcbl9xdWV1ZUhlYWRVcmwgPSBuZXcgV2Vha01hcCgpO1xuX3F1ZXVlVGFpbFVybCA9IG5ldyBXZWFrTWFwKCk7XG5fUHJlZmV0Y2hRdWV1ZV9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpO1xucHJlZmV0Y2hfZm4gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHVybCA9IGFyZ3NbMF0udG9TdHJpbmcoKTtcbiAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfcHJlZmV0Y2hRdWV1ZSkuc2l6ZSA+PSBfX3ByaXZhdGVHZXQodGhpcywgX21heFByZWZldGNoZWRSZXF1ZXN0cykpIHJldHVybjtcbiAgY29uc3QgYWJvcnRlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gX19wcml2YXRlR2V0KHRoaXMsIF9mZXRjaENsaWVudCkuY2FsbCh0aGlzLCB1cmwsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIChfYSA9IGFyZ3NbMV0pICE9IG51bGwgPyBfYSA6IHt9KSwge1xuICAgICAgc2lnbmFsOiBjaGFpbkFib3J0ZXIoYWJvcnRlciwgKF9iID0gYXJnc1sxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNpZ25hbClcbiAgICB9KSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9wcmVmZXRjaFF1ZXVlKS5zZXQodXJsLCBbcmVxdWVzdCwgYWJvcnRlcl0pO1xuICAgIHJlcXVlc3QudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgIGlmICghcmVzcG9uc2Uub2sgfHwgYWJvcnRlci5zaWduYWwuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgY29uc3QgbmV4dFVybCA9IGdldE5leHRDaHVua1VybCh1cmwsIHJlc3BvbnNlKTtcbiAgICAgIGlmICghbmV4dFVybCB8fCBuZXh0VXJsID09PSB1cmwpIHtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9xdWV1ZVRhaWxVcmwsIHZvaWQgMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfcXVldWVUYWlsVXJsLCBuZXh0VXJsKTtcbiAgICAgIHJldHVybiBfX3ByaXZhdGVNZXRob2QodGhpcywgX1ByZWZldGNoUXVldWVfaW5zdGFuY2VzLCBwcmVmZXRjaF9mbikuY2FsbCh0aGlzLCBuZXh0VXJsLCBhcmdzWzFdKTtcbiAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldE5leHRDaHVua1VybCh1cmwsIHJlcykge1xuICBjb25zdCBzaGFwZUhhbmRsZSA9IHJlcy5oZWFkZXJzLmdldChTSEFQRV9IQU5ETEVfSEVBREVSKTtcbiAgY29uc3QgbGFzdE9mZnNldCA9IHJlcy5oZWFkZXJzLmdldChDSFVOS19MQVNUX09GRlNFVF9IRUFERVIpO1xuICBjb25zdCBpc1VwVG9EYXRlID0gcmVzLmhlYWRlcnMuaGFzKENIVU5LX1VQX1RPX0RBVEVfSEVBREVSKTtcbiAgaWYgKCFzaGFwZUhhbmRsZSB8fCAhbGFzdE9mZnNldCB8fCBpc1VwVG9EYXRlKSByZXR1cm47XG4gIGNvbnN0IG5leHRVcmwgPSBuZXcgVVJMKHVybCk7XG4gIGlmIChuZXh0VXJsLnNlYXJjaFBhcmFtcy5oYXMoTElWRV9RVUVSWV9QQVJBTSkpIHJldHVybjtcbiAgbmV4dFVybC5zZWFyY2hQYXJhbXMuc2V0KFNIQVBFX0hBTkRMRV9RVUVSWV9QQVJBTSwgc2hhcGVIYW5kbGUpO1xuICBuZXh0VXJsLnNlYXJjaFBhcmFtcy5zZXQoT0ZGU0VUX1FVRVJZX1BBUkFNLCBsYXN0T2Zmc2V0KTtcbiAgbmV4dFVybC5zZWFyY2hQYXJhbXMuc29ydCgpO1xuICByZXR1cm4gbmV4dFVybC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gY2hhaW5BYm9ydGVyKGFib3J0ZXIsIHNvdXJjZVNpZ25hbCkge1xuICBpZiAoIXNvdXJjZVNpZ25hbCkgcmV0dXJuIGFib3J0ZXIuc2lnbmFsO1xuICBpZiAoc291cmNlU2lnbmFsLmFib3J0ZWQpIGFib3J0ZXIuYWJvcnQoKTtcbiAgZWxzZVxuICAgIHNvdXJjZVNpZ25hbC5hZGRFdmVudExpc3RlbmVyKGBhYm9ydGAsICgpID0+IGFib3J0ZXIuYWJvcnQoKSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICByZXR1cm4gYWJvcnRlci5zaWduYWw7XG59XG5cbi8vIHNyYy9jbGllbnQudHNcbnZhciBSRVNFUlZFRF9QQVJBTVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIExJVkVfQ0FDSEVfQlVTVEVSX1FVRVJZX1BBUkFNLFxuICBTSEFQRV9IQU5ETEVfUVVFUllfUEFSQU0sXG4gIExJVkVfUVVFUllfUEFSQU0sXG4gIE9GRlNFVF9RVUVSWV9QQVJBTVxuXSk7XG5mdW5jdGlvbiB0b0ludGVybmFsUGFyYW1zKHBhcmFtcykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgIHJlc3VsdFtrZXldID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKGAsYCkgOiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIF9lcnJvciwgX2ZldGNoQ2xpZW50MiwgX21lc3NhZ2VQYXJzZXIsIF9zdWJzY3JpYmVycywgX2xhc3RPZmZzZXQsIF9saXZlQ2FjaGVCdXN0ZXIsIF9sYXN0U3luY2VkQXQsIF9pc1VwVG9EYXRlLCBfY29ubmVjdGVkLCBfc2hhcGVIYW5kbGUsIF9zY2hlbWEsIF9vbkVycm9yLCBfU2hhcGVTdHJlYW1faW5zdGFuY2VzLCBzdGFydF9mbiwgcHVibGlzaF9mbiwgc2VuZEVycm9yVG9TdWJzY3JpYmVyc19mbiwgcmVzZXRfZm47XG52YXIgU2hhcGVTdHJlYW0gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX1NoYXBlU3RyZWFtX2luc3RhbmNlcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9lcnJvciwgbnVsbCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9mZXRjaENsaWVudDIpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbWVzc2FnZVBhcnNlcik7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zdWJzY3JpYmVycywgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9sYXN0T2Zmc2V0KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2xpdmVDYWNoZUJ1c3Rlcik7XG4gICAgLy8gU2Vjb25kcyBzaW5jZSBvdXIgRWxlY3RyaWMgRXBvY2gg8J+YjlxuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbGFzdFN5bmNlZEF0KTtcbiAgICAvLyB1bml4IHRpbWVcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2lzVXBUb0RhdGUsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2Nvbm5lY3RlZCwgZmFsc2UpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2hhcGVIYW5kbGUpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2NoZW1hKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uRXJyb3IpO1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHRoaXMub3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHsgc3Vic2NyaWJlOiB0cnVlIH0sIG9wdGlvbnMpO1xuICAgIHZhbGlkYXRlT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbGFzdE9mZnNldCwgKF9hID0gdGhpcy5vcHRpb25zLm9mZnNldCkgIT0gbnVsbCA/IF9hIDogYC0xYCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9saXZlQ2FjaGVCdXN0ZXIsIGBgKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3NoYXBlSGFuZGxlLCB0aGlzLm9wdGlvbnMuaGFuZGxlKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX21lc3NhZ2VQYXJzZXIsIG5ldyBNZXNzYWdlUGFyc2VyKG9wdGlvbnMucGFyc2VyKSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9vbkVycm9yLCB0aGlzLm9wdGlvbnMub25FcnJvcik7XG4gICAgY29uc3QgYmFzZUZldGNoQ2xpZW50ID0gKF9iID0gb3B0aW9ucy5mZXRjaENsaWVudCkgIT0gbnVsbCA/IF9iIDogKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xuICAgIGNvbnN0IGZldGNoV2l0aEJhY2tvZmZDbGllbnQgPSBjcmVhdGVGZXRjaFdpdGhCYWNrb2ZmKGJhc2VGZXRjaENsaWVudCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgKF9jID0gb3B0aW9ucy5iYWNrb2ZmT3B0aW9ucykgIT0gbnVsbCA/IF9jIDogQmFja29mZkRlZmF1bHRzKSwge1xuICAgICAgb25GYWlsZWRBdHRlbXB0OiAoKSA9PiB7XG4gICAgICAgIHZhciBfYTIsIF9iMjtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9jb25uZWN0ZWQsIGZhbHNlKTtcbiAgICAgICAgKF9iMiA9IChfYTIgPSBvcHRpb25zLmJhY2tvZmZPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm9uRmFpbGVkQXR0ZW1wdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5jYWxsKF9hMik7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZmV0Y2hDbGllbnQyLCBjcmVhdGVGZXRjaFdpdGhSZXNwb25zZUhlYWRlcnNDaGVjayhcbiAgICAgIGNyZWF0ZUZldGNoV2l0aENodW5rQnVmZmVyKGZldGNoV2l0aEJhY2tvZmZDbGllbnQpXG4gICAgKSk7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9TaGFwZVN0cmVhbV9pbnN0YW5jZXMsIHN0YXJ0X2ZuKS5jYWxsKHRoaXMpO1xuICB9XG4gIGdldCBzaGFwZUhhbmRsZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9zaGFwZUhhbmRsZSk7XG4gIH1cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2Vycm9yKTtcbiAgfVxuICBnZXQgaXNVcFRvRGF0ZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9pc1VwVG9EYXRlKTtcbiAgfVxuICBnZXQgbGFzdE9mZnNldCgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9sYXN0T2Zmc2V0KTtcbiAgfVxuICBzdWJzY3JpYmUoY2FsbGJhY2ssIG9uRXJyb3IgPSAoKSA9PiB7XG4gIH0pIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25JZCA9IE1hdGgucmFuZG9tKCk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zdWJzY3JpYmVycykuc2V0KHN1YnNjcmlwdGlvbklkLCBbY2FsbGJhY2ssIG9uRXJyb3JdKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9zdWJzY3JpYmVycykuZGVsZXRlKHN1YnNjcmlwdGlvbklkKTtcbiAgICB9O1xuICB9XG4gIHVuc3Vic2NyaWJlQWxsKCkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc3Vic2NyaWJlcnMpLmNsZWFyKCk7XG4gIH1cbiAgLyoqIFVuaXggdGltZSBhdCB3aGljaCB3ZSBsYXN0IHN5bmNlZC4gVW5kZWZpbmVkIHdoZW4gYGlzTG9hZGluZ2AgaXMgdHJ1ZS4gKi9cbiAgbGFzdFN5bmNlZEF0KCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2xhc3RTeW5jZWRBdCk7XG4gIH1cbiAgLyoqIFRpbWUgZWxhcHNlZCBzaW5jZSBsYXN0IHN5bmMgKGluIG1zKS4gSW5maW5pdHkgaWYgd2UgZGlkIG5vdCB5ZXQgc3luYy4gKi9cbiAgbGFzdFN5bmNlZCgpIHtcbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9sYXN0U3luY2VkQXQpID09PSB2b2lkIDApIHJldHVybiBJbmZpbml0eTtcbiAgICByZXR1cm4gRGF0ZS5ub3coKSAtIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGFzdFN5bmNlZEF0KTtcbiAgfVxuICAvKiogSW5kaWNhdGVzIGlmIHdlIGFyZSBjb25uZWN0ZWQgdG8gdGhlIEVsZWN0cmljIHN5bmMgc2VydmljZS4gKi9cbiAgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfY29ubmVjdGVkKTtcbiAgfVxuICAvKiogVHJ1ZSBkdXJpbmcgaW5pdGlhbCBmZXRjaC4gRmFsc2UgYWZ0ZXJ3aXNlLiAgKi9cbiAgaXNMb2FkaW5nKCkge1xuICAgIHJldHVybiAhX19wcml2YXRlR2V0KHRoaXMsIF9pc1VwVG9EYXRlKTtcbiAgfVxufTtcbl9lcnJvciA9IG5ldyBXZWFrTWFwKCk7XG5fZmV0Y2hDbGllbnQyID0gbmV3IFdlYWtNYXAoKTtcbl9tZXNzYWdlUGFyc2VyID0gbmV3IFdlYWtNYXAoKTtcbl9zdWJzY3JpYmVycyA9IG5ldyBXZWFrTWFwKCk7XG5fbGFzdE9mZnNldCA9IG5ldyBXZWFrTWFwKCk7XG5fbGl2ZUNhY2hlQnVzdGVyID0gbmV3IFdlYWtNYXAoKTtcbl9sYXN0U3luY2VkQXQgPSBuZXcgV2Vha01hcCgpO1xuX2lzVXBUb0RhdGUgPSBuZXcgV2Vha01hcCgpO1xuX2Nvbm5lY3RlZCA9IG5ldyBXZWFrTWFwKCk7XG5fc2hhcGVIYW5kbGUgPSBuZXcgV2Vha01hcCgpO1xuX3NjaGVtYSA9IG5ldyBXZWFrTWFwKCk7XG5fb25FcnJvciA9IG5ldyBXZWFrTWFwKCk7XG5fU2hhcGVTdHJlYW1faW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKTtcbnN0YXJ0X2ZuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKCEoKF9hID0gdGhpcy5vcHRpb25zLnNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmFib3J0ZWQpICYmICFfX3ByaXZhdGVHZXQodGhpcywgX2lzVXBUb0RhdGUpIHx8IHRoaXMub3B0aW9ucy5zdWJzY3JpYmUpIHtcbiAgICAgICAgY29uc3QgeyB1cmwsIHNpZ25hbCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBmZXRjaFVybCA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgICBjb25zdCByZXNlcnZlZFBhcmFtcyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5wYXJhbXMpLmZpbHRlcihcbiAgICAgICAgICAgIChrZXkpID0+IFJFU0VSVkVEX1BBUkFNUy5oYXMoa2V5KVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHJlc2VydmVkUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYENhbm5vdCB1c2UgcmVzZXJ2ZWQgRWxlY3RyaWMgcGFyYW1ldGVyIG5hbWVzIGluIGN1c3RvbSBwYXJhbXM6ICR7cmVzZXJ2ZWRQYXJhbXMuam9pbihgLCBgKX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB0b0ludGVybmFsUGFyYW1zKHRoaXMub3B0aW9ucy5wYXJhbXMpO1xuICAgICAgICAgIGlmIChwYXJhbXMudGFibGUpXG4gICAgICAgICAgICBmZXRjaFVybC5zZWFyY2hQYXJhbXMuc2V0KFRBQkxFX1FVRVJZX1BBUkFNLCBwYXJhbXMudGFibGUpO1xuICAgICAgICAgIGlmIChwYXJhbXMud2hlcmUpXG4gICAgICAgICAgICBmZXRjaFVybC5zZWFyY2hQYXJhbXMuc2V0KFdIRVJFX1FVRVJZX1BBUkFNLCBwYXJhbXMud2hlcmUpO1xuICAgICAgICAgIGlmIChwYXJhbXMuY29sdW1ucylcbiAgICAgICAgICAgIGZldGNoVXJsLnNlYXJjaFBhcmFtcy5zZXQoQ09MVU1OU19RVUVSWV9QQVJBTSwgcGFyYW1zLmNvbHVtbnMpO1xuICAgICAgICAgIGlmIChwYXJhbXMucmVwbGljYSlcbiAgICAgICAgICAgIGZldGNoVXJsLnNlYXJjaFBhcmFtcy5zZXQoUkVQTElDQV9QQVJBTSwgcGFyYW1zLnJlcGxpY2EpO1xuICAgICAgICAgIGNvbnN0IGN1c3RvbVBhcmFtcyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBwYXJhbXMpO1xuICAgICAgICAgIGRlbGV0ZSBjdXN0b21QYXJhbXMudGFibGU7XG4gICAgICAgICAgZGVsZXRlIGN1c3RvbVBhcmFtcy53aGVyZTtcbiAgICAgICAgICBkZWxldGUgY3VzdG9tUGFyYW1zLmNvbHVtbnM7XG4gICAgICAgICAgZGVsZXRlIGN1c3RvbVBhcmFtcy5yZXBsaWNhO1xuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGN1c3RvbVBhcmFtcykpIHtcbiAgICAgICAgICAgIGZldGNoVXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZldGNoVXJsLnNlYXJjaFBhcmFtcy5zZXQoT0ZGU0VUX1FVRVJZX1BBUkFNLCBfX3ByaXZhdGVHZXQodGhpcywgX2xhc3RPZmZzZXQpKTtcbiAgICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfaXNVcFRvRGF0ZSkpIHtcbiAgICAgICAgICBmZXRjaFVybC5zZWFyY2hQYXJhbXMuc2V0KExJVkVfUVVFUllfUEFSQU0sIGB0cnVlYCk7XG4gICAgICAgICAgZmV0Y2hVcmwuc2VhcmNoUGFyYW1zLnNldChcbiAgICAgICAgICAgIExJVkVfQ0FDSEVfQlVTVEVSX1FVRVJZX1BBUkFNLFxuICAgICAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXZlQ2FjaGVCdXN0ZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9zaGFwZUhhbmRsZSkpIHtcbiAgICAgICAgICBmZXRjaFVybC5zZWFyY2hQYXJhbXMuc2V0KFxuICAgICAgICAgICAgU0hBUEVfSEFORExFX1FVRVJZX1BBUkFNLFxuICAgICAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9zaGFwZUhhbmRsZSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGZldGNoVXJsLnNlYXJjaFBhcmFtcy5zb3J0KCk7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIF9fcHJpdmF0ZUdldCh0aGlzLCBfZmV0Y2hDbGllbnQyKS5jYWxsKHRoaXMsIGZldGNoVXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMub3B0aW9ucy5oZWFkZXJzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9jb25uZWN0ZWQsIHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGZXRjaEJhY2tvZmZBYm9ydEVycm9yKSBicmVhaztcbiAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgRmV0Y2hFcnJvcikpIHRocm93IGU7XG4gICAgICAgICAgaWYgKGUuc3RhdHVzID09IDQwOSkge1xuICAgICAgICAgICAgY29uc3QgbmV3U2hhcGVIYW5kbGUgPSBlLmhlYWRlcnNbU0hBUEVfSEFORExFX0hFQURFUl07XG4gICAgICAgICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX1NoYXBlU3RyZWFtX2luc3RhbmNlcywgcmVzZXRfZm4pLmNhbGwodGhpcywgbmV3U2hhcGVIYW5kbGUpO1xuICAgICAgICAgICAgeWllbGQgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9TaGFwZVN0cmVhbV9pbnN0YW5jZXMsIHB1Ymxpc2hfZm4pLmNhbGwodGhpcywgZS5qc29uKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZS5zdGF0dXMgPj0gNDAwICYmIGUuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX1NoYXBlU3RyZWFtX2luc3RhbmNlcywgc2VuZEVycm9yVG9TdWJzY3JpYmVyc19mbikuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaGVhZGVycywgc3RhdHVzIH0gPSByZXNwb25zZTtcbiAgICAgICAgY29uc3Qgc2hhcGVIYW5kbGUgPSBoZWFkZXJzLmdldChTSEFQRV9IQU5ETEVfSEVBREVSKTtcbiAgICAgICAgaWYgKHNoYXBlSGFuZGxlKSB7XG4gICAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9zaGFwZUhhbmRsZSwgc2hhcGVIYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RPZmZzZXQgPSBoZWFkZXJzLmdldChDSFVOS19MQVNUX09GRlNFVF9IRUFERVIpO1xuICAgICAgICBpZiAobGFzdE9mZnNldCkge1xuICAgICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbGFzdE9mZnNldCwgbGFzdE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGl2ZUNhY2hlQnVzdGVyID0gaGVhZGVycy5nZXQoTElWRV9DQUNIRV9CVVNURVJfSEVBREVSKTtcbiAgICAgICAgaWYgKGxpdmVDYWNoZUJ1c3Rlcikge1xuICAgICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbGl2ZUNhY2hlQnVzdGVyLCBsaXZlQ2FjaGVCdXN0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdldFNjaGVtYSA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzY2hlbWFIZWFkZXIgPSBoZWFkZXJzLmdldChTSEFQRV9TQ0hFTUFfSEVBREVSKTtcbiAgICAgICAgICByZXR1cm4gc2NoZW1hSGVhZGVyID8gSlNPTi5wYXJzZShzY2hlbWFIZWFkZXIpIDoge307XG4gICAgICAgIH07XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfc2NoZW1hLCAoX2IgPSBfX3ByaXZhdGVHZXQodGhpcywgX3NjaGVtYSkpICE9IG51bGwgPyBfYiA6IGdldFNjaGVtYSgpKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBzdGF0dXMgPT09IDIwNCA/IGBbXWAgOiB5aWVsZCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwNCkge1xuICAgICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbGFzdFN5bmNlZEF0LCBEYXRlLm5vdygpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXRjaCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWVzc2FnZVBhcnNlcikucGFyc2UobWVzc2FnZXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2NoZW1hKSk7XG4gICAgICAgIGlmIChiYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBiYXRjaFtiYXRjaC5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAoaXNVcFRvRGF0ZU1lc3NhZ2UobGFzdE1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2xhc3RTeW5jZWRBdCwgRGF0ZS5ub3coKSk7XG4gICAgICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2lzVXBUb0RhdGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5aWVsZCBfX3ByaXZhdGVNZXRob2QodGhpcywgX1NoYXBlU3RyZWFtX2luc3RhbmNlcywgcHVibGlzaF9mbikuY2FsbCh0aGlzLCBiYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZXJyb3IsIGVycik7XG4gICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9vbkVycm9yKSkge1xuICAgICAgICBjb25zdCByZXRyeU9wdHMgPSB5aWVsZCBfX3ByaXZhdGVHZXQodGhpcywgX29uRXJyb3IpLmNhbGwodGhpcywgZXJyKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXRyeU9wdHMgPT09IGBvYmplY3RgKSB7XG4gICAgICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9TaGFwZVN0cmVhbV9pbnN0YW5jZXMsIHJlc2V0X2ZuKS5jYWxsKHRoaXMpO1xuICAgICAgICAgIGlmIChgcGFyYW1zYCBpbiByZXRyeU9wdHMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wYXJhbXMgPSByZXRyeU9wdHMucGFyYW1zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYGhlYWRlcnNgIGluIHJldHJ5T3B0cykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhlYWRlcnMgPSByZXRyeU9wdHMuaGVhZGVycztcbiAgICAgICAgICB9XG4gICAgICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9TaGFwZVN0cmVhbV9pbnN0YW5jZXMsIHN0YXJ0X2ZuKS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9jb25uZWN0ZWQsIGZhbHNlKTtcbiAgICB9XG4gIH0pO1xufTtcbnB1Ymxpc2hfZm4gPSBmdW5jdGlvbihtZXNzYWdlcykge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIHlpZWxkIFByb21pc2UuYWxsKFxuICAgICAgQXJyYXkuZnJvbShfX3ByaXZhdGVHZXQodGhpcywgX3N1YnNjcmliZXJzKS52YWx1ZXMoKSkubWFwKChfMCkgPT4gX19hc3luYyh0aGlzLCBbXzBdLCBmdW5jdGlvbiogKFtjYWxsYmFjaywgX19dKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeWllbGQgY2FsbGJhY2sobWVzc2FnZXMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgICk7XG4gIH0pO1xufTtcbnNlbmRFcnJvclRvU3Vic2NyaWJlcnNfZm4gPSBmdW5jdGlvbihlcnJvcikge1xuICBfX3ByaXZhdGVHZXQodGhpcywgX3N1YnNjcmliZXJzKS5mb3JFYWNoKChbXywgZXJyb3JGbl0pID0+IHtcbiAgICBlcnJvckZuID09IG51bGwgPyB2b2lkIDAgOiBlcnJvckZuKGVycm9yKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBSZXNldHMgdGhlIHN0YXRlIG9mIHRoZSBzdHJlYW0sIG9wdGlvbmFsbHkgd2l0aCBhIHByb3ZpZGVkXG4gKiBzaGFwZSBoYW5kbGVcbiAqL1xucmVzZXRfZm4gPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgX19wcml2YXRlU2V0KHRoaXMsIF9sYXN0T2Zmc2V0LCBgLTFgKTtcbiAgX19wcml2YXRlU2V0KHRoaXMsIF9saXZlQ2FjaGVCdXN0ZXIsIGBgKTtcbiAgX19wcml2YXRlU2V0KHRoaXMsIF9zaGFwZUhhbmRsZSwgaGFuZGxlKTtcbiAgX19wcml2YXRlU2V0KHRoaXMsIF9pc1VwVG9EYXRlLCBmYWxzZSk7XG4gIF9fcHJpdmF0ZVNldCh0aGlzLCBfY29ubmVjdGVkLCBmYWxzZSk7XG4gIF9fcHJpdmF0ZVNldCh0aGlzLCBfc2NoZW1hLCB2b2lkIDApO1xufTtcblNoYXBlU3RyZWFtLlJlcGxpY2EgPSB7XG4gIEZVTEw6IGBmdWxsYCxcbiAgREVGQVVMVDogYGRlZmF1bHRgXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLnVybCkge1xuICAgIHRocm93IG5ldyBNaXNzaW5nU2hhcGVVcmxFcnJvcigpO1xuICB9XG4gIGlmIChvcHRpb25zLnNpZ25hbCAmJiAhKG9wdGlvbnMuc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRTaWduYWxFcnJvcigpO1xuICB9XG4gIGlmIChvcHRpb25zLm9mZnNldCAhPT0gdm9pZCAwICYmIG9wdGlvbnMub2Zmc2V0ICE9PSBgLTFgICYmICFvcHRpb25zLmhhbmRsZSkge1xuICAgIHRocm93IG5ldyBNaXNzaW5nU2hhcGVIYW5kbGVFcnJvcigpO1xuICB9XG4gIGlmIChvcHRpb25zLnBhcmFtcykge1xuICAgIGNvbnN0IHJlc2VydmVkUGFyYW1zID0gT2JqZWN0LmtleXMob3B0aW9ucy5wYXJhbXMpLmZpbHRlcihcbiAgICAgIChrZXkpID0+IFJFU0VSVkVEX1BBUkFNUy5oYXMoa2V5KVxuICAgICk7XG4gICAgaWYgKHJlc2VydmVkUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSZXNlcnZlZFBhcmFtRXJyb3IocmVzZXJ2ZWRQYXJhbXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm47XG59XG5cbi8vIHNyYy9zaGFwZS50c1xudmFyIF9kYXRhLCBfc3Vic2NyaWJlcnMyLCBfaGFzTm90aWZpZWRTdWJzY3JpYmVyc1VwVG9EYXRlLCBfZXJyb3IyLCBfU2hhcGVfaW5zdGFuY2VzLCBwcm9jZXNzX2ZuLCBoYW5kbGVFcnJvcl9mbiwgbm90aWZ5X2ZuO1xudmFyIFNoYXBlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX1NoYXBlX2luc3RhbmNlcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9kYXRhLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3N1YnNjcmliZXJzMiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYXNOb3RpZmllZFN1YnNjcmliZXJzVXBUb0RhdGUsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2Vycm9yMiwgZmFsc2UpO1xuICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuc3RyZWFtLnN1YnNjcmliZShcbiAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfU2hhcGVfaW5zdGFuY2VzLCBwcm9jZXNzX2ZuKS5iaW5kKHRoaXMpLFxuICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9TaGFwZV9pbnN0YW5jZXMsIGhhbmRsZUVycm9yX2ZuKS5iaW5kKHRoaXMpXG4gICAgKTtcbiAgfVxuICBnZXQgaXNVcFRvRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW0uaXNVcFRvRGF0ZTtcbiAgfVxuICBnZXQgbGFzdE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW0ubGFzdE9mZnNldDtcbiAgfVxuICBnZXQgaGFuZGxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbS5zaGFwZUhhbmRsZTtcbiAgfVxuICBnZXQgcm93cygpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS50aGVuKCh2KSA9PiBBcnJheS5mcm9tKHYudmFsdWVzKCkpKTtcbiAgfVxuICBnZXQgY3VycmVudFJvd3MoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jdXJyZW50VmFsdWUudmFsdWVzKCkpO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RyZWFtLmlzVXBUb0RhdGUpIHtcbiAgICAgICAgcmVzb2x2ZSh0aGlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMuc3Vic2NyaWJlKCh7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2Vycm9yMikpIHJlamVjdChfX3ByaXZhdGVHZXQodGhpcywgX2Vycm9yMikpO1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgY3VycmVudFZhbHVlKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2RhdGEpO1xuICB9XG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9lcnJvcjIpO1xuICB9XG4gIC8qKiBVbml4IHRpbWUgYXQgd2hpY2ggd2UgbGFzdCBzeW5jZWQuIFVuZGVmaW5lZCB3aGVuIGBpc0xvYWRpbmdgIGlzIHRydWUuICovXG4gIGxhc3RTeW5jZWRBdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW0ubGFzdFN5bmNlZEF0KCk7XG4gIH1cbiAgLyoqIFRpbWUgZWxhcHNlZCBzaW5jZSBsYXN0IHN5bmMgKGluIG1zKS4gSW5maW5pdHkgaWYgd2UgZGlkIG5vdCB5ZXQgc3luYy4gKi9cbiAgbGFzdFN5bmNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW0ubGFzdFN5bmNlZCgpO1xuICB9XG4gIC8qKiBUcnVlIGR1cmluZyBpbml0aWFsIGZldGNoLiBGYWxzZSBhZnRlcndpc2UuICAqL1xuICBpc0xvYWRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtLmlzTG9hZGluZygpO1xuICB9XG4gIC8qKiBJbmRpY2F0ZXMgaWYgd2UgYXJlIGNvbm5lY3RlZCB0byB0aGUgRWxlY3RyaWMgc3luYyBzZXJ2aWNlLiAqL1xuICBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW0uaXNDb25uZWN0ZWQoKTtcbiAgfVxuICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25JZCA9IE1hdGgucmFuZG9tKCk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zdWJzY3JpYmVyczIpLnNldChzdWJzY3JpcHRpb25JZCwgY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3N1YnNjcmliZXJzMikuZGVsZXRlKHN1YnNjcmlwdGlvbklkKTtcbiAgICB9O1xuICB9XG4gIHVuc3Vic2NyaWJlQWxsKCkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc3Vic2NyaWJlcnMyKS5jbGVhcigpO1xuICB9XG4gIGdldCBudW1TdWJzY3JpYmVycygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9zdWJzY3JpYmVyczIpLnNpemU7XG4gIH1cbn07XG5fZGF0YSA9IG5ldyBXZWFrTWFwKCk7XG5fc3Vic2NyaWJlcnMyID0gbmV3IFdlYWtNYXAoKTtcbl9oYXNOb3RpZmllZFN1YnNjcmliZXJzVXBUb0RhdGUgPSBuZXcgV2Vha01hcCgpO1xuX2Vycm9yMiA9IG5ldyBXZWFrTWFwKCk7XG5fU2hhcGVfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKTtcbnByb2Nlc3NfZm4gPSBmdW5jdGlvbihtZXNzYWdlcykge1xuICBsZXQgZGF0YU1heUhhdmVDaGFuZ2VkID0gZmFsc2U7XG4gIGxldCBpc1VwVG9EYXRlID0gZmFsc2U7XG4gIGxldCBuZXdseVVwVG9EYXRlID0gZmFsc2U7XG4gIG1lc3NhZ2VzLmZvckVhY2goKG1lc3NhZ2UpID0+IHtcbiAgICBpZiAoaXNDaGFuZ2VNZXNzYWdlKG1lc3NhZ2UpKSB7XG4gICAgICBkYXRhTWF5SGF2ZUNoYW5nZWQgPSBbYGluc2VydGAsIGB1cGRhdGVgLCBgZGVsZXRlYF0uaW5jbHVkZXMoXG4gICAgICAgIG1lc3NhZ2UuaGVhZGVycy5vcGVyYXRpb25cbiAgICAgICk7XG4gICAgICBzd2l0Y2ggKG1lc3NhZ2UuaGVhZGVycy5vcGVyYXRpb24pIHtcbiAgICAgICAgY2FzZSBgaW5zZXJ0YDpcbiAgICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2RhdGEpLnNldChtZXNzYWdlLmtleSwgbWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgYHVwZGF0ZWA6XG4gICAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9kYXRhKS5zZXQobWVzc2FnZS5rZXksIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBfX3ByaXZhdGVHZXQodGhpcywgX2RhdGEpLmdldChtZXNzYWdlLmtleSkpLCBtZXNzYWdlLnZhbHVlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgYGRlbGV0ZWA6XG4gICAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9kYXRhKS5kZWxldGUobWVzc2FnZS5rZXkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNDb250cm9sTWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgc3dpdGNoIChtZXNzYWdlLmhlYWRlcnMuY29udHJvbCkge1xuICAgICAgICBjYXNlIGB1cC10by1kYXRlYDpcbiAgICAgICAgICBpc1VwVG9EYXRlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfaGFzTm90aWZpZWRTdWJzY3JpYmVyc1VwVG9EYXRlKSkge1xuICAgICAgICAgICAgbmV3bHlVcFRvRGF0ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGBtdXN0LXJlZmV0Y2hgOlxuICAgICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZGF0YSkuY2xlYXIoKTtcbiAgICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2Vycm9yMiwgZmFsc2UpO1xuICAgICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaGFzTm90aWZpZWRTdWJzY3JpYmVyc1VwVG9EYXRlLCBmYWxzZSk7XG4gICAgICAgICAgaXNVcFRvRGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIG5ld2x5VXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAobmV3bHlVcFRvRGF0ZSB8fCBpc1VwVG9EYXRlICYmIGRhdGFNYXlIYXZlQ2hhbmdlZCkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaGFzTm90aWZpZWRTdWJzY3JpYmVyc1VwVG9EYXRlLCB0cnVlKTtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX1NoYXBlX2luc3RhbmNlcywgbm90aWZ5X2ZuKS5jYWxsKHRoaXMpO1xuICB9XG59O1xuaGFuZGxlRXJyb3JfZm4gPSBmdW5jdGlvbihlKSB7XG4gIGlmIChlIGluc3RhbmNlb2YgRmV0Y2hFcnJvcikge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZXJyb3IyLCBlKTtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX1NoYXBlX2luc3RhbmNlcywgbm90aWZ5X2ZuKS5jYWxsKHRoaXMpO1xuICB9XG59O1xubm90aWZ5X2ZuID0gZnVuY3Rpb24oKSB7XG4gIF9fcHJpdmF0ZUdldCh0aGlzLCBfc3Vic2NyaWJlcnMyKS5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgIGNhbGxiYWNrKHsgdmFsdWU6IHRoaXMuY3VycmVudFZhbHVlLCByb3dzOiB0aGlzLmN1cnJlbnRSb3dzIH0pO1xuICB9KTtcbn07XG5leHBvcnQge1xuICBCYWNrb2ZmRGVmYXVsdHMsXG4gIEZldGNoRXJyb3IsXG4gIFNoYXBlLFxuICBTaGFwZVN0cmVhbSxcbiAgaXNDaGFuZ2VNZXNzYWdlLFxuICBpc0NvbnRyb2xNZXNzYWdlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@electric-sql/client/dist/index.mjs\n");

/***/ })

};
;